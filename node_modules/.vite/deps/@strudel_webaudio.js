import {
  Ee,
  Of,
  Ou,
  ct,
  dist_exports,
  f,
  j,
  l,
  q,
  qc,
  qe,
  tt
} from "./chunk-X2KHC3MF.js";
import "./chunk-UVKRO5ER.js";

// node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/nanostores/map/index.js
var map = (initial = {}) => {
  let $map = atom(initial);
  $map.setKey = function(key, value) {
    let oldMap = $map.value;
    if (typeof value === "undefined" && key in $map.value) {
      $map.value = { ...$map.value };
      delete $map.value[key];
      $map.notify(oldMap, key);
    } else if ($map.value[key] !== value) {
      $map.value = {
        ...$map.value,
        [key]: value
      };
      $map.notify(oldMap, key);
    }
  };
  return $map;
};

// node_modules/superdough/dist/index.mjs
if (typeof DelayNode < "u") {
  class t extends DelayNode {
    constructor(n, c, o, a) {
      super(n), c = Math.abs(c), this.delayTime.value = o;
      const s = n.createGain();
      s.gain.value = Math.min(Math.abs(a), 0.995), this.feedback = s.gain;
      const l2 = n.createGain();
      return l2.gain.value = c, this.delayGain = l2, this.connect(s), this.connect(l2), s.connect(this), this.connect = (d) => l2.connect(d), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(e, n, c) {
    return new t(this, e, n, c);
  };
}
var Yt = {};
Yt.generateReverb = function(t, e) {
  for (var n = t.audioContext || new AudioContext(), c = n.sampleRate, o = t.numChannels || 2, a = t.decayTime * 1.5, s = Math.round(t.decayTime * c), l2 = Math.round(a * c), d = Math.round((t.fadeInTime || 0) * c), r = Math.pow(1 / 1e3, 1 / s), i = n.createBuffer(o, l2, c), b2 = 0; b2 < o; b2++) {
    for (var u = i.getChannelData(b2), m = 0; m < l2; m++)
      u[m] = ke() * Math.pow(r, m);
    for (var m = 0; m < d; m++)
      u[m] *= m / d;
  }
  Ie(i, t.lpFreqStart || 0, t.lpFreqEnd || 0, t.decayTime, e);
};
Yt.generateGraph = function(t, e, n, c, o) {
  var a = document.createElement("canvas");
  a.width = e, a.height = n;
  var s = a.getContext("2d");
  s.fillStyle = "#000", s.fillRect(0, 0, a.width, a.height), s.fillStyle = "#fff";
  for (var l2 = e / t.length, d = n / (o - c), r = 0; r < t.length; r++)
    s.fillRect(r * l2, n - (t[r] - c) * d, 1, 1);
  return a;
};
var Ie = function(t, e, n, c, o) {
  if (e == 0) {
    o(t);
    return;
  }
  var a = Pe(t), s = new OfflineAudioContext(t.numberOfChannels, a[0].length, t.sampleRate), l2 = s.createBufferSource();
  l2.buffer = t;
  var d = s.createBiquadFilter();
  e = Math.min(e, t.sampleRate / 2), n = Math.min(n, t.sampleRate / 2), d.type = "lowpass", d.Q.value = 1e-4, d.frequency.setValueAtTime(e, 0), d.frequency.linearRampToValueAtTime(n, c), l2.connect(d), d.connect(s.destination), l2.start(), s.oncomplete = function(r) {
    o(r.renderedBuffer);
  }, s.startRendering(), window.filterNode = d;
};
var Pe = function(t) {
  for (var e = [], n = 0; n < t.numberOfChannels; n++)
    e[n] = t.getChannelData(n);
  return e;
};
var ke = function() {
  return Math.random() * 2 - 1;
};
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(t, e) {
  const n = e.sampleRate * t, c = this.createBuffer(e.numberOfChannels, e.length, e.sampleRate);
  for (let o = 0; o < e.numberOfChannels; o++) {
    let a = e.getChannelData(o), s = c.getChannelData(o);
    for (let l2 = 0; l2 < n; l2++)
      s[l2] = a[l2] || 0;
  }
  return c;
}, AudioContext.prototype.createReverb = function(t, e, n, c, o) {
  const a = this.createConvolver();
  return a.generate = (s = 2, l2 = 0.1, d = 15e3, r = 1e3, i) => {
    a.duration = s, a.fade = l2, a.lp = d, a.dim = r, a.ir = i, i ? a.buffer = this.adjustLength(s, i) : Yt.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: s,
        fadeInTime: l2,
        lpFreqStart: d,
        lpFreqEnd: r
      },
      (b2) => {
        a.buffer = b2;
      }
    );
  }, a.generate(t, e, n, c, o), a;
});
var oe = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class t extends GainNode {
    constructor(n, c) {
      if (super(n), !oe[c])
        throw new Error("vowel: unknown vowel " + c);
      const { gains: o, qs: a, freqs: s } = oe[c], l2 = n.createGain();
      for (let d = 0; d < 5; d++) {
        const r = n.createGain();
        r.gain.value = o[d];
        const i = n.createBiquadFilter();
        i.type = "bandpass", i.Q.value = a[d], i.frequency.value = s[d], this.connect(i), i.connect(r), r.connect(l2);
      }
      return l2.gain.value = 8, this.connect = (d) => l2.connect(d), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(e) {
    return new t(this, e);
  };
}
var ie = (t) => console.log(t);
var F = (...t) => ie(...t);
var Tn = (t) => {
  ie = t;
};
var Be = (t) => {
  var _a;
  if (typeof t != "string")
    return [];
  const [e, n = "", c] = ((_a = t.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)) == null ? void 0 : _a.slice(1)) || [];
  return e ? [e, n, c ? Number(c) : void 0] : [];
};
var ve = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 };
var Qe = { "#": 1, b: -1, s: 1, f: -1 };
var yt = (t, e = 3) => {
  const [n, c, o = e] = Be(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const a = ve[n.toLowerCase()], s = (c == null ? void 0 : c.split("").reduce((l2, d) => l2 + Qe[d], 0)) || 0;
  return (Number(o) + 1) * 12 + a + s;
};
var ue = (t) => Math.pow(2, (t - 69) / 12) * 440;
var st = (t, e, n) => Math.min(Math.max(t, e), n);
var je = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69;
var Ue = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: c } = t;
  return typeof n == "number" ? je(n) : typeof c == "string" ? yt(c) : typeof c == "number" ? c : e;
};
function Q(t, e = 0, n) {
  return isNaN(Number(t)) ? (!n && F(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
var me = (t, e) => (t % e + e) % e;
var se = (t, e) => me(Math.round(Q(t, 0)), e);
var Oe = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHZ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBuPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW4/ITE6KHRoaXMuc3RhcnRlZD1uLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBndHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgYT1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MoYSksZVtzKzFdPS1NYXRoLnNpbihhKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbj0xO3RoaXMuc2l6ZT5uO248PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgaD0wO2g8dGhpcy5fd2lkdGg7aCs9Mil7dmFyIGM9dGhpcy5fd2lkdGgtaC0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj5oJjMpPDxjfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG49ZS9yPDwxLGksaCxjPXRoaXMuX2JpdHJldjtpZihuPT09NClmb3IoaT0wLGg9MDtpPGU7aSs9bixoKyspe2NvbnN0IG09Y1toXTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksbSxyKX1lbHNlIGZvcihpPTAsaD0wO2k8ZTtpKz1uLGgrKyl7Y29uc3QgbT1jW2hdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxtLHIpfXZhciBhPXRoaXMuX2ludj8tMToxLHU9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bj1lL3I8PDE7dmFyIGY9bj4+PjI7Zm9yKGk9MDtpPGU7aSs9bilmb3IodmFyIHA9aStmLGw9aSxkPTA7bDxwO2wrPTIsZCs9cil7Y29uc3QgbT1sLGc9bStmLHY9ZytmLEk9ditmLF89dFttXSx3PXRbbSsxXSxiPXRbZ10sQj10W2crMV0sVD10W3ZdLFA9dFt2KzFdLHk9dFtJXSxBPXRbSSsxXSx4PV8sRj13LFY9dVtkXSxNPWEqdVtkKzFdLE89YipWLUIqTSxOPWIqTStCKlYsWT11WzIqZF0sTD1hKnVbMipkKzFdLEg9VCpZLVAqTCxVPVQqTCtQKlksSz11WzMqZF0sWj1hKnVbMypkKzFdLCQ9eSpLLUEqWixHPXkqWitBKkssaj14K0gsQz1GK1Usaz14LUgsSj1GLVUsUT1PKyQsej1OK0csRT1hKihPLSQpLFg9YSooTi1HKSxldD1qK1EsaXQ9Qyt6LG90PWotUSxhdD1DLXosaHQ9aytYLHV0PUotRSxjdD1rLVgsbHQ9SitFO3RbbV09ZXQsdFttKzFdPWl0LHRbZ109aHQsdFtnKzFdPXV0LHRbdl09b3QsdFt2KzFdPWF0LHRbSV09Y3QsdFtJKzFdPWx0fX19X3NpbmdsZVRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPW5bZV0saD1uW2UrMV0sYz1uW2Urc10sYT1uW2UrcysxXSx1PWkrYyxmPWgrYSxwPWktYyxsPWgtYTtyW3RdPXUsclt0KzFdPWYsclt0KzJdPXAsclt0KzNdPWx9X3NpbmdsZVRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLGg9cyoyLGM9cyozLGE9bltlXSx1PW5bZSsxXSxmPW5bZStzXSxwPW5bZStzKzFdLGw9bltlK2hdLGQ9bltlK2grMV0sbT1uW2UrY10sZz1uW2UrYysxXSx2PWErbCxJPXUrZCxfPWEtbCx3PXUtZCxiPWYrbSxCPXArZyxUPWkqKGYtbSksUD1pKihwLWcpLHk9ditiLEE9SStCLHg9XytQLEY9dy1ULFY9di1iLE09SS1CLE89Xy1QLE49dytUO3JbdF09eSxyW3QrMV09QSxyW3QrMl09eCxyW3QrM109RixyW3QrNF09VixyW3QrNV09TSxyW3QrNl09TyxyW3QrN109Tn1fcmVhbFRyYW5zZm9ybTQoKXt2YXIgdD10aGlzLl9vdXQsZT10aGlzLl9jc2l6ZSxzPXRoaXMuX3dpZHRoLHI9MTw8cyxuPWUvcjw8MSxpLGgsYz10aGlzLl9iaXRyZXY7aWYobj09PTQpZm9yKGk9MCxoPTA7aTxlO2krPW4saCsrKXtjb25zdCBmdD1jW2hdO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGksZnQ+Pj4xLHI+Pj4xKX1lbHNlIGZvcihpPTAsaD0wO2k8ZTtpKz1uLGgrKyl7Y29uc3QgZnQ9Y1toXTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChpLGZ0Pj4+MSxyPj4+MSl9dmFyIGE9dGhpcy5faW52Py0xOjEsdT10aGlzLnRhYmxlO2ZvcihyPj49MjtyPj0yO3I+Pj0yKXtuPWUvcjw8MTt2YXIgZj1uPj4+MSxwPWY+Pj4xLGw9cD4+PjE7Zm9yKGk9MDtpPGU7aSs9bilmb3IodmFyIGQ9MCxtPTA7ZDw9bDtkKz0yLG0rPXIpe3ZhciBnPWkrZCx2PWcrcCxJPXYrcCxfPUkrcCx3PXRbZ10sYj10W2crMV0sQj10W3ZdLFQ9dFt2KzFdLFA9dFtJXSx5PXRbSSsxXSxBPXRbX10seD10W18rMV0sRj13LFY9YixNPXVbbV0sTz1hKnVbbSsxXSxOPUIqTS1UKk8sWT1CKk8rVCpNLEw9dVsyKm1dLEg9YSp1WzIqbSsxXSxVPVAqTC15KkgsSz1QKkgreSpMLFo9dVszKm1dLCQ9YSp1WzMqbSsxXSxHPUEqWi14KiQsaj1BKiQreCpaLEM9RitVLGs9VitLLEo9Ri1VLFE9Vi1LLHo9TitHLEU9WStqLFg9YSooTi1HKSxldD1hKihZLWopLGl0PUMreixvdD1rK0UsYXQ9SitldCxodD1RLVg7aWYodFtnXT1pdCx0W2crMV09b3QsdFt2XT1hdCx0W3YrMV09aHQsZD09PTApe3ZhciB1dD1DLXosY3Q9ay1FO3RbSV09dXQsdFtJKzFdPWN0O2NvbnRpbnVlfWlmKGQhPT1sKXt2YXIgbHQ9Six6dD0tUSxFdD1DLFJ0PS1rLER0PS1hKmV0LHF0PS1hKlgsV3Q9LWEqRSxZdD0tYSp6LEx0PWx0K0R0LEh0PXp0K3F0LFV0PUV0K1l0LEt0PVJ0LVd0LGR0PWkrcC1kLG10PWkrZi1kO3RbZHRdPUx0LHRbZHQrMV09SHQsdFttdF09VXQsdFttdCsxXT1LdH19fX1fc2luZ2xlUmVhbFRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPW5bZV0saD1uW2Urc10sYz1pK2gsYT1pLWg7clt0XT1jLHJbdCsxXT0wLHJbdCsyXT1hLHJbdCszXT0wfV9zaW5nbGVSZWFsVHJhbnNmb3JtNCh0LGUscyl7Y29uc3Qgcj10aGlzLl9vdXQsbj10aGlzLl9kYXRhLGk9dGhpcy5faW52Py0xOjEsaD1zKjIsYz1zKjMsYT1uW2VdLHU9bltlK3NdLGY9bltlK2hdLHA9bltlK2NdLGw9YStmLGQ9YS1mLG09dStwLGc9aSoodS1wKSx2PWwrbSxJPWQsXz0tZyx3PWwtbSxiPWQsQj1nO3JbdF09dixyW3QrMV09MCxyW3QrMl09SSxyW3QrM109XyxyW3QrNF09dyxyW3QrNV09MCxyW3QrNl09YixyW3QrN109Qn19Y29uc3QgUj0obyx0LGUpPT5NYXRoLm1pbihNYXRoLm1heChvLHQpLGUpLEl0PShvLHQpPT4obyV0K3QpJXQsRD0xMjg7ZnVuY3Rpb24gYnQobyx0KXtyZXR1cm4gbzx0PyhvLz10LG8rby1vKm8tMSk6bz4xLXQ/KG89KG8tMSkvdCxvKm8rbytvKzEpOjB9Y29uc3Qgc3Q9e3RyaShvLHQ9LjUpe2NvbnN0IGU9MS10O3JldHVybiBvPj10PzEvZS1vL2U6by90fSxzaW5lKG8pe3JldHVybiBNYXRoLnNpbihNYXRoLlBJKjIqbykqLjUrLjV9LHJhbXAobyl7cmV0dXJuIG99LHNhdyhvKXtyZXR1cm4gMS1vfSxzcXVhcmUobyx0PS41KXtyZXR1cm4gbz49dD8wOjF9LGN1c3RvbShvLHQ9WzAsMV0pe2NvbnN0IGU9dC5sZW5ndGgtMSxzPU1hdGguZmxvb3IobyplKSxyPTEvZSxuPVIodFtzXSwwLDEpLGg9Uih0W3MrMV0sMCwxKSxjPW4sYT0wLHU9cjtyZXR1cm4oaC1jKS8odS1hKSooby1yKnMpK259LHNhd2JsZXAobyx0KXtyZXR1cm4gMipvLTEtYnQobyx0KX19O2Z1bmN0aW9uIHEobyx0KXtyZXR1cm4gdC5sZW5ndGg+MT90W29dOnRbMF19Y29uc3QgQnQ9T2JqZWN0LmtleXMoc3QpO2NsYXNzIF90IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InRpbWUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToic2tldyIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToiZGVwdGgiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToicGhhc2VvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZGNvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGhhc2V9aW5jcmVtZW50UGhhc2UodCl7dGhpcy5waGFzZSs9dCx0aGlzLnBoYXNlPjEmJih0aGlzLnBoYXNlPXRoaXMucGhhc2UtMSl9cHJvY2Vzcyh0LGUscyl7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXSxuPXMuZnJlcXVlbmN5WzBdLGk9cy50aW1lWzBdLGg9cy5kZXB0aFswXSxjPXMuc2tld1swXSxhPXMucGhhc2VvZmZzZXRbMF0sdT1zLmRjb2Zmc2V0WzBdLGY9QnRbcy5zaGFwZVswXV0scD1yWzBdLmxlbmd0aD8/MDt0aGlzLnBoYXNlPT1udWxsJiYodGhpcy5waGFzZT1JdChpKm4rYSwxKSk7Y29uc3QgbD1uL3NhbXBsZVJhdGU7Zm9yKGxldCBkPTA7ZDxwO2QrKyl7Zm9yKGxldCBtPTA7bTxyLmxlbmd0aDttKyspe2NvbnN0IGc9KHN0W2ZdKHRoaXMucGhhc2UsYykrdSkqaDtyW21dW2RdPWd9dGhpcy5pbmNyZW1lbnRQaGFzZShsKX1yZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImxmby1wcm9jZXNzb3IiLF90KTtjbGFzcyB3dCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJjb2Fyc2UiLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCBoPXMuY29hcnNlWzBdPz8wO2g9TWF0aC5tYXgoMSxoKTtmb3IobGV0IGM9MDtjPEQ7YysrKWZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKW5bYV1bY109YyVoPT09MD9yW2FdW2NdOm5bYV1bYy0xXTtyZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImNvYXJzZS1wcm9jZXNzb3IiLHd0KTtjbGFzcyBTdCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJjcnVzaCIsZGVmYXVsdFZhbHVlOjB9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IGg9cy5jcnVzaFswXT8/ODtoPU1hdGgubWF4KDEsaCk7Zm9yKGxldCBjPTA7YzxEO2MrKylmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKyl7Y29uc3QgdT1NYXRoLnBvdygyLGgtMSk7blthXVtjXT1NYXRoLnJvdW5kKHJbYV1bY10qdSkvdX1yZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImNydXNoLXByb2Nlc3NvciIsU3QpO2NsYXNzIFR0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InNoYXBlIixkZWZhdWx0VmFsdWU6MH0se25hbWU6InBvc3RnYWluIixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG49ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgaD1zLnNoYXBlWzBdO2g9aDwxP2g6MS00ZS0xMCxoPTIqaC8oMS1oKTtjb25zdCBjPU1hdGgubWF4KC4wMDEsTWF0aC5taW4oMSxzLnBvc3RnYWluWzBdKSk7Zm9yKGxldCBhPTA7YTxEO2ErKylmb3IobGV0IHU9MDt1PHIubGVuZ3RoO3UrKyluW3VdW2FdPSgxK2gpKnJbdV1bYV0vKDEraCpNYXRoLmFicyhyW3VdW2FdKSkqYztyZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoInNoYXBlLXByb2Nlc3NvciIsVHQpO2Z1bmN0aW9uIFMobyl7Y29uc3QgdD1vKm87cmV0dXJuIG8qKDI3K3QpLygyNys5KnQpfWNvbnN0IHB0PTMuMTQxNTkyNjUzNTk7Y2xhc3MgUHQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NTAwfSx7bmFtZToicSIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJkcml2ZSIsZGVmYXVsdFZhbHVlOi42OX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITEsdGhpcy5wMD1bMCwwXSx0aGlzLnAxPVswLDBdLHRoaXMucDI9WzAsMF0sdGhpcy5wMz1bMCwwXSx0aGlzLnAzMj1bMCwwXSx0aGlzLnAzMz1bMCwwXSx0aGlzLnAzND1bMCwwXX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IGg9cy5xWzBdLGM9UihNYXRoLmV4cChzLmRyaXZlWzBdKSwuMSwyZTMpO2xldCBhPXMuZnJlcXVlbmN5WzBdO2E9YSoyKnB0L3NhbXBsZVJhdGUsYT1hPjE/MTphO2NvbnN0IHU9TWF0aC5taW4oOCxoKi4xMyk7bGV0IGY9MS9jKk1hdGgubWluKDEuNzUsMSt1KTtmb3IobGV0IHA9MDtwPEQ7cCsrKWZvcihsZXQgbD0wO2w8ci5sZW5ndGg7bCsrKXtjb25zdCBkPXRoaXMucDNbbF0qLjM2MDg5MSt0aGlzLnAzMltsXSouNDE3MjkrdGhpcy5wMzNbbF0qLjE3Nzg5Nit0aGlzLnAzNFtsXSouMDQzOTcyNTt0aGlzLnAzNFtsXT10aGlzLnAzM1tsXSx0aGlzLnAzM1tsXT10aGlzLnAzMltsXSx0aGlzLnAzMltsXT10aGlzLnAzW2xdLHRoaXMucDBbbF0rPShTKHJbbF1bcF0qYy11KmQpLVModGhpcy5wMFtsXSkpKmEsdGhpcy5wMVtsXSs9KFModGhpcy5wMFtsXSktUyh0aGlzLnAxW2xdKSkqYSx0aGlzLnAyW2xdKz0oUyh0aGlzLnAxW2xdKS1TKHRoaXMucDJbbF0pKSphLHRoaXMucDNbbF0rPShTKHRoaXMucDJbbF0pLVModGhpcy5wM1tsXSkpKmEsbltsXVtwXT1kKmZ9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJsYWRkZXItcHJvY2Vzc29yIixQdCk7Y2xhc3MgeXQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiZGlzdG9ydCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJwb3N0Z2FpbiIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7Y29uc3QgaD1NYXRoLmV4cG0xKHMuZGlzdG9ydFswXSksYz1NYXRoLm1heCguMDAxLE1hdGgubWluKDEscy5wb3N0Z2FpblswXSkpO2ZvcihsZXQgYT0wO2E8RDthKyspZm9yKGxldCB1PTA7dTxyLmxlbmd0aDt1Kyspblt1XVthXT0oMStoKSpyW3VdW2FdLygxK2gqTWF0aC5hYnMoclt1XVthXSkpKmM7cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJkaXN0b3J0LXByb2Nlc3NvciIseXQpO2Z1bmN0aW9uIEF0KG8sdCxlKXtyZXR1cm4gZSoodC1vKStvfWZ1bmN0aW9uIHh0KG8sdCxlKXtyZXR1cm4gbzwyPzA6QXQoLXQqLjUsdCouNSxlLyhvLTEpKX1mdW5jdGlvbiBydChvLHQpe3JldHVybiBvKk1hdGgucG93KDIsdC8xMil9Y2xhc3MgRnQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGhhc2U9W119c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo0NDAsbWluOk51bWJlci5FUFNJTE9OfSx7bmFtZToicGFuc3ByZWFkIixkZWZhdWx0VmFsdWU6LjQsbWluOjAsbWF4OjF9LHtuYW1lOiJmcmVxc3ByZWFkIixkZWZhdWx0VmFsdWU6LjIsbWluOjB9LHtuYW1lOiJkZXR1bmUiLGRlZmF1bHRWYWx1ZTowLG1pbjowfSx7bmFtZToidm9pY2VzIixkZWZhdWx0VmFsdWU6NSxtaW46MX1dfXByb2Nlc3ModCxlLHMpe2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTtsZXQgcj1zLmZyZXF1ZW5jeVswXTtyPXIqTWF0aC5wb3coMixzLmRldHVuZVswXS8xMjAwKTtjb25zdCBuPWVbMF0saT1zLnZvaWNlc1swXSxoPXMuZnJlcXNwcmVhZFswXSxjPXMucGFuc3ByZWFkWzBdKi41Ky41LGE9TWF0aC5zcXJ0KDEtYyksdT1NYXRoLnNxcnQoYyk7Zm9yKGxldCBmPTA7ZjxpO2YrKyl7Y29uc3QgcD0oZiYxKT09MSxsPXJ0KHIseHQoaSxoLGYpKTtsZXQgZD1hLG09dTtwJiYoZD11LG09YSk7Y29uc3QgZz1sL3NhbXBsZVJhdGU7Zm9yKGxldCB2PTA7djxuWzBdLmxlbmd0aDt2Kyspe3RoaXMucGhhc2VbZl09dGhpcy5waGFzZVtmXT8/TWF0aC5yYW5kb20oKTtjb25zdCBJPXN0LnNhd2JsZXAodGhpcy5waGFzZVtmXSxnKTtuWzBdW3ZdPW5bMF1bdl0rSSpkLG5bMV1bdl09blsxXVt2XStJKm0sdGhpcy5waGFzZVtmXSs9Zyx0aGlzLnBoYXNlW2ZdPjEmJih0aGlzLnBoYXNlW2ZdPXRoaXMucGhhc2VbZl0tMSl9fXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3Nvcigic3VwZXJzYXctb3NjaWxsYXRvciIsRnQpO2NvbnN0IFZ0PTIwNDg7ZnVuY3Rpb24gTXQobyl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShvKTtmb3IodmFyIGU9MDtlPG87ZSsrKXRbZV09LjUqKDEtTWF0aC5jb3MoMipNYXRoLlBJKmUvbykpO3JldHVybiB0fWNsYXNzIE90IGV4dGVuZHMgdnR7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToicGl0Y2hGYWN0b3IiLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IodCl7dC5wcm9jZXNzb3JPcHRpb25zPXtibG9ja1NpemU6VnR9LHN1cGVyKHQpLHRoaXMuZmZ0U2l6ZT10aGlzLmJsb2NrU2l6ZSx0aGlzLnRpbWVDdXJzb3I9MCx0aGlzLmhhbm5XaW5kb3c9TXQodGhpcy5ibG9ja1NpemUpLHRoaXMuZmZ0PW5ldyBndCh0aGlzLmZmdFNpemUpLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXI9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQ9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy50aW1lQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLm1hZ25pdHVkZXM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmZmdFNpemUvMisxKSx0aGlzLnBlYWtJbmRleGVzPW5ldyBJbnQzMkFycmF5KHRoaXMubWFnbml0dWRlcy5sZW5ndGgpLHRoaXMubmJQZWFrcz0wfXByb2Nlc3NPTEEodCxlLHMpe2xldCByPXMucGl0Y2hGYWN0b3Jbcy5waXRjaEZhY3Rvci5sZW5ndGgtMV07cjwwJiYocj1yKi4yNSkscj1NYXRoLm1heCgwLHIrMSk7Zm9yKHZhciBuPTA7bjx0aGlzLm5iSW5wdXRzO24rKylmb3IodmFyIGk9MDtpPHRbbl0ubGVuZ3RoO2krKyl7dmFyIGg9dFtuXVtpXSxjPWVbbl1baV07dGhpcy5hcHBseUhhbm5XaW5kb3coaCksdGhpcy5mZnQucmVhbFRyYW5zZm9ybSh0aGlzLmZyZXFDb21wbGV4QnVmZmVyLGgpLHRoaXMuY29tcHV0ZU1hZ25pdHVkZXMoKSx0aGlzLmZpbmRQZWFrcygpLHRoaXMuc2hpZnRQZWFrcyhyKSx0aGlzLmZmdC5jb21wbGV0ZVNwZWN0cnVtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkKSx0aGlzLmZmdC5pbnZlcnNlVHJhbnNmb3JtKHRoaXMudGltZUNvbXBsZXhCdWZmZXIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmZyb21Db21wbGV4QXJyYXkodGhpcy50aW1lQ29tcGxleEJ1ZmZlcixjKSx0aGlzLmFwcGx5SGFubldpbmRvdyhjKX10aGlzLnRpbWVDdXJzb3IrPXRoaXMuaG9wU2l6ZX1hcHBseUhhbm5XaW5kb3codCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmJsb2NrU2l6ZTtlKyspdFtlXT10W2VdKnRoaXMuaGFubldpbmRvd1tlXSoxLjYyfWNvbXB1dGVNYWduaXR1ZGVzKCl7Zm9yKHZhciB0PTAsZT0wO3Q8dGhpcy5tYWduaXR1ZGVzLmxlbmd0aDspe2xldCBzPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZV0scj10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2UrMV07dGhpcy5tYWduaXR1ZGVzW3RdPXMqKjIrcioqMix0Kz0xLGUrPTJ9fWZpbmRQZWFrcygpe3RoaXMubmJQZWFrcz0wO3ZhciB0PTI7bGV0IGU9dGhpcy5tYWduaXR1ZGVzLmxlbmd0aC0yO2Zvcig7dDxlOyl7bGV0IHM9dGhpcy5tYWduaXR1ZGVzW3RdO2lmKHRoaXMubWFnbml0dWRlc1t0LTFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdC0yXT49cyl7dCsrO2NvbnRpbnVlfWlmKHRoaXMubWFnbml0dWRlc1t0KzFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdCsyXT49cyl7dCsrO2NvbnRpbnVlfXRoaXMucGVha0luZGV4ZXNbdGhpcy5uYlBlYWtzXT10LHRoaXMubmJQZWFrcysrLHQrPTJ9fXNoaWZ0UGVha3ModCl7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQuZmlsbCgwKTtmb3IodmFyIGU9MDtlPHRoaXMubmJQZWFrcztlKyspe2xldCBpPXRoaXMucGVha0luZGV4ZXNbZV0saD1NYXRoLnJvdW5kKGkqdCk7aWYoaD50aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO3ZhciBzPTAscj10aGlzLmZmdFNpemU7aWYoZT4wKXtsZXQgdT10aGlzLnBlYWtJbmRleGVzW2UtMV07cz1pLU1hdGguZmxvb3IoKGktdSkvMil9aWYoZTx0aGlzLm5iUGVha3MtMSl7bGV0IHU9dGhpcy5wZWFrSW5kZXhlc1tlKzFdO3I9aStNYXRoLmNlaWwoKHUtaSkvMil9bGV0IGM9cy1pLGE9ci1pO2Zvcih2YXIgbj1jO248YTtuKyspe2xldCB1PWkrbixmPWgrbjtpZihmPj10aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO2xldCBwPTIqTWF0aC5QSSooZi11KS90aGlzLmZmdFNpemUsbD1NYXRoLmNvcyhwKnRoaXMudGltZUN1cnNvciksZD1NYXRoLnNpbihwKnRoaXMudGltZUN1cnNvciksbT11KjIsZz1tKzEsdj10aGlzLmZyZXFDb21wbGV4QnVmZmVyW21dLEk9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltnXSxfPXYqbC1JKmQsdz12KmQrSSpsLGI9ZioyLEI9YisxO3RoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW2JdKz1fLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW0JdKz13fX19fXJlZ2lzdGVyUHJvY2Vzc29yKCJwaGFzZS12b2NvZGVyLXByb2Nlc3NvciIsT3QpO2NsYXNzIE50IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBpPXB0LHRoaXMucGhpPS10aGlzLnBpLHRoaXMuWTA9MCx0aGlzLlkxPTAsdGhpcy5QVz10aGlzLnBpLHRoaXMuQj0yLjMsdGhpcy5kcGhpZj0wLHRoaXMuZW52Zj0wfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToicHVsc2V3aWR0aCIsZGVmYXVsdFZhbHVlOjEsbWluOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTtjb25zdCByPWVbMF07bGV0IG49MSxpO2ZvcihsZXQgaD0wO2g8KHJbMF0ubGVuZ3RoPz8wKTtoKyspe2NvbnN0IGM9KDEtUihxKGgscy5wdWxzZXdpZHRoKSwtLjk5LC45OSkpKnRoaXMucGksYT1xKGgscy5kZXR1bmUpLHU9cnQocShoLHMuZnJlcXVlbmN5KSxhLzEwMCk7aT11Kih0aGlzLnBpLyhzYW1wbGVSYXRlKi41KSksdGhpcy5kcGhpZis9LjEqKGktdGhpcy5kcGhpZiksbio9Ljk5OTgsdGhpcy5lbnZmKz0uMSoobi10aGlzLmVudmYpLHRoaXMuQj0yLjMqKDEtMWUtNCp1KSx0aGlzLkI8MCYmKHRoaXMuQj0wKSx0aGlzLnBoaSs9dGhpcy5kcGhpZix0aGlzLnBoaT49dGhpcy5waSYmKHRoaXMucGhpLT0yKnRoaXMucGkpO2xldCBmPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkwKTt0aGlzLlkwPS41KihmK3RoaXMuWTApO2xldCBwPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkxK2MpO3RoaXMuWTE9LjUqKHArdGhpcy5ZMSk7Zm9yKGxldCBsPTA7bDxyLmxlbmd0aDtsKyspcltsXVtoXT0uMTUqKGYtcCkqdGhpcy5lbnZmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigicHVsc2Utb3NjaWxsYXRvciIsTnQpO2NvbnN0IG50PXtiaXRDOmZ1bmN0aW9uKG8sdCxlKXtyZXR1cm4gbyZ0P2U6MH0sYnI6ZnVuY3Rpb24obyx0PTgpe2lmKHQ+MzIpdGhyb3cgbmV3IEVycm9yKCJicigpIFNpemUgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAzMiIpO3tsZXQgZT0wO2ZvcihsZXQgcz0wO3M8dC0wO3MrKyllKz1udC5iaXRDKG8sMioqcywyKioodC0ocysxKSkpO3JldHVybiBlfX0sc2luZjpmdW5jdGlvbihvKXtyZXR1cm4gTWF0aC5zaW4oby8oMTI4L01hdGguUEkpKX0sY29zZjpmdW5jdGlvbihvKXtyZXR1cm4gTWF0aC5jb3Moby8oMTI4L01hdGguUEkpKX0sdGFuZjpmdW5jdGlvbihvKXtyZXR1cm4gTWF0aC50YW4oby8oMTI4L01hdGguUEkpKX0scmVnRzpmdW5jdGlvbihvLHQpe3JldHVybiB0LnRlc3Qoby50b1N0cmluZygyKSl9fTtsZXQgVyx0dDtmdW5jdGlvbiBDdChvKXtpZigoV3x8dHQpPT1udWxsKXtXPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hdGgpLHR0PVcubWFwKHM9Pk1hdGhbc10pO2NvbnN0IHQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobnQpLGU9dC5tYXAocz0+bnRbc10pO1cucHVzaCgiaW50Iiwid2luZG93IiwuLi50KSx0dC5wdXNoKE1hdGguZmxvb3IsZ2xvYmFsVGhpcywuLi5lKX1yZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLlcsInQiLGByZXR1cm4gMCwKJHtvfHwwfTtgKS5iaW5kKGdsb2JhbFRoaXMsLi4udHQpfWNsYXNzIGt0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBvcnQub25tZXNzYWdlPXQ9PntsZXR7Y29kZVRleHQ6ZX09dC5kYXRhO2NvbnN0e2J5dGVCZWF0U3RhcnRUaW1lOnN9PXQuZGF0YTtzIT1udWxsJiYodGhpcy50PTAsdGhpcy5pbml0aWFsT2Zmc2V0PU1hdGguZmxvb3IocykpLGU9ZS50cmltKCkucmVwbGFjZSgvXmV2YWxcKHVuZXNjYXBlXChlc2NhcGUoPzpgfFwoJ3xcKCJ8XChgKSguKj8pKD86YHwnXCl8IlwpfGBcKSkucmVwbGFjZVwoXC91XChcLlwuXClcL2csWyInYF1cJDElWyInYF1cKVwpXCkkLywocixuKT0+dW5lc2NhcGUoZXNjYXBlKG4pLnJlcGxhY2UoL3UoLi4pL2csIiQxJSIpKSksdGhpcy5mdW5jPUN0KGUpfSx0aGlzLmluaXRpYWxPZmZzZXQ9bnVsbCx0aGlzLnQ9bnVsbCx0aGlzLmZ1bmM9bnVsbH1zdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJiZWdpbiIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjQ0MCxtaW46TnVtYmVyLkVQU0lMT059LHtuYW1lOiJkZXR1bmUiLGRlZmF1bHRWYWx1ZTowLG1pbjpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX0se25hbWU6ImVuZCIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTt0aGlzLnQ9PW51bGwmJih0aGlzLnQ9cy5iZWdpblswXSpzYW1wbGVSYXRlKTtjb25zdCByPWVbMF07Zm9yKGxldCBuPTA7bjxyWzBdLmxlbmd0aDtuKyspe2NvbnN0IGk9cShuLHMuZGV0dW5lKSxoPXJ0KHEobixzLmZyZXF1ZW5jeSksaS8xMDApO2xldCBjPXRoaXMudC8oc2FtcGxlUmF0ZS8yNTYpKmgrdGhpcy5pbml0aWFsT2Zmc2V0O2NvbnN0IGY9KCh0aGlzLmZ1bmMoYykmMjU1KS8xMjcuNS0xKSouMjtmb3IobGV0IHA9MDtwPHIubGVuZ3RoO3ArKylyW3BdW25dPVIoZiwtLjQsLjQpO3RoaXMudD10aGlzLnQrMX1yZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoImJ5dGUtYmVhdC1wcm9jZXNzb3IiLGt0KX0pKCk7Cg==";
function k(t) {
  const e = G().createGain();
  return e.gain.value = t, e;
}
var ae = (t, e, n, c) => c - n === 0 ? 0 : (e - t) / (c - n);
function I(t, e, n, c) {
  const o = new AudioWorkletNode(t, e, c);
  return Object.entries(n).forEach(([a, s]) => {
    o.parameters.get(a).value = s;
  }), o;
}
var B = (t, e, n, c, o, a, s, l2, d, r = "exponential") => {
  e = Q(e), n = Q(n), c = Q(c), o = Q(o);
  const i = r === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  r === "exponential" && (a = a === 0 ? 1e-3 : a, s = s === 0 ? 1e-3 : s);
  const b2 = s - a, u = s, m = a + c * b2, X = d - l2, Z2 = (p) => {
    let y;
    if (e > p) {
      let h = ae(a, u, 0, e);
      y = p * h + (a > u ? a : 0);
    } else
      y = (p - e) * ae(u, m, 0, n) + u;
    return r === "exponential" && (y = y || 1e-3), y;
  };
  t.setValueAtTime(a, l2), e > X ? t[i](Z2(X), d) : e + n > X ? (t[i](Z2(e), l2 + e), t[i](Z2(X), d)) : (t[i](Z2(e), l2 + e), t[i](Z2(e + n), l2 + e + n), t.setValueAtTime(m, d)), t[i](a, d + o);
};
function De(t, e, n, c, o, a) {
  const s = {
    threshold: e ?? -3,
    ratio: n ?? 10,
    knee: c ?? 10,
    attack: o ?? 5e-3,
    release: a ?? 0.05
  };
  return new DynamicsCompressorNode(t, s);
}
var v = (t, e = "linear", n) => {
  const [s, l2, d, r] = t;
  if (s == null && l2 == null && d == null && r == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const i = d ?? (s != null && l2 == null || s == null && l2 == null ? 1 : 1e-3);
  return [Math.max(s ?? 0, 1e-3), Math.max(l2 ?? 0, 1e-3), Math.min(i, 1), Math.max(r ?? 0, 0.01)];
};
function zt(t, e, n, c, o, a, s, l2, d, r, i, b2, u, m) {
  const X = "exponential", [Z2, p, y, h] = v([o, a, s, l2], X, [5e-3, 0.14, 0, 0.1]);
  let V2, f2;
  if (u === "ladder" ? (V2 = I(t, "ladder-processor", { frequency: n, q: c, drive: m }), f2 = V2.parameters.get("frequency")) : (V2 = t.createBiquadFilter(), V2.type = e, V2.Q.value = c, V2.frequency.value = n, f2 = V2.frequency), (o ?? a ?? s ?? l2 ?? d) !== void 0) {
    d = Q(d, 1, true), b2 = Q(b2, 0, true);
    const M = Math.abs(d), N = M * b2;
    let g = st(2 ** -N * n, 0, 2e4), S2 = st(2 ** (M - N) * n, 0, 2e4);
    return d < 0 && ([g, S2] = [S2, g]), B(f2, Z2, p, y, h, g, S2, r, i, X), V2;
  }
  return V2;
}
var le = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
function Ee2(t, e, n = 0) {
  const c = G();
  if (!n)
    return t;
  let o = c.createGain(), a = c.createGain();
  t.connect(o), e.connect(a), o.gain.value = le(n), a.gain.value = le(1 - n);
  let s = c.createGain();
  return o.connect(s), a.connect(s), s;
}
var Ae = ["linear", "exponential"];
function Xt(t, e, n, c) {
  if (!(e.pattack ?? e.pdecay ?? e.psustain ?? e.prelease ?? e.penv))
    return;
  const a = Q(e.penv, 1, true), s = Ae[e.pcurve ?? 0];
  let [l2, d, r, i] = v(
    [e.pattack, e.pdecay, e.psustain, e.prelease],
    s,
    [0.2, 1e-3, 1, 1e-3]
  ), b2 = e.panchor ?? r;
  const u = a * 100, m = 0 - u * b2, X = u - u * b2;
  B(t, l2, d, r, i, m, X, n, c, s);
}
function Zt(t, e, n) {
  const { vibmod: c = 0.5, vib: o } = e;
  let a;
  if (o > 0) {
    a = G().createOscillator(), a.frequency.value = o;
    const s = G().createGain();
    return s.gain.value = c * 100, a.connect(s), s.connect(t), a.start(n), a;
  }
}
function Rt(t, e, n, c) {
  const o = t.createConstantSource();
  return o.start(n), o.stop(c), o.onended = () => {
    e();
  }, o;
}
var qe2 = (t, e = 1, n = "sine") => {
  const c = G(), o = c.createOscillator();
  o.type = n, o.frequency.value = t, o.start();
  const a = new GainNode(c, { gain: e });
  return o.connect(a), { node: a, stop: (s) => o.stop(s) };
};
var _e = (t, e, n, c = "sine") => {
  const a = t.value * e, s = a * n;
  return qe2(a, s, c);
};
function Ft(t, e, n) {
  const {
    fmh: c = 1,
    fmi: o,
    fmenv: a = "exp",
    fmattack: s,
    fmdecay: l2,
    fmsustain: d,
    fmrelease: r,
    fmvelocity: i,
    fmwave: b2 = "sine",
    duration: u
  } = e;
  let m, X = () => {
  };
  if (o) {
    const p = G().createGain(), y = _e(t, c, o, b2);
    if (m = y.node, X = y.stop, ![s, l2, d, r, i].find((h) => h !== void 0))
      m.connect(t);
    else {
      const [h, V2, f2, x] = v([s, l2, d, r]), M = n + u;
      B(
        p.gain,
        h,
        V2,
        f2,
        x,
        0,
        1,
        n,
        M,
        a === "exp" ? "exponential" : "linear"
      ), m.connect(p), p.connect(t);
    }
  }
  return { stop: X };
}
var Jt = {};
var Lt = {};
var wn = (t) => Jt[t];
function $e(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var c = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], o = -1;
  do
    t /= n, ++o;
  while (t >= n);
  return t.toFixed(1) + " " + c[o];
}
function tn(t, e) {
  const { s: n, n: c = 0, speed: o = 1 } = t;
  let a = Ue(t, 36), s = a - 36, l2, d = 0;
  if (Array.isArray(e))
    d = se(c, e.length), l2 = e[d];
  else {
    const b2 = (m) => yt(m) - a, u = Object.keys(e).filter((m) => !m.startsWith("_")).reduce(
      (m, X, Z2) => !m || Math.abs(b2(X)) < Math.abs(b2(m)) ? X : m,
      null
    );
    s = -b2(u), d = se(c, e[u].length), l2 = e[u][d];
  }
  const r = `${n}:${d}`;
  let i = Math.abs(o) * Math.pow(2, s / 12);
  return { transpose: s, sampleUrl: l2, index: d, midi: a, label: r, playbackRate: i };
}
var en = async (t, e, n) => {
  let { sampleUrl: c, label: o, playbackRate: a } = tn(t, e);
  n && (c = await n(c));
  const s = G(), l2 = await be(c, s, o);
  return t.unit === "c" && (a = a * l2.duration), { buffer: l2, playbackRate: a };
};
var nn = async (t, e, n) => {
  let { buffer: c, playbackRate: o } = await en(t, e, n);
  t.speed < 0 && (c = cn(c));
  const s = G().createBufferSource();
  s.buffer = c, s.playbackRate.value = o;
  const { s: l2, loopBegin: d = 0, loopEnd: r = 1, begin: i = 0, end: b2 = 1 } = t, u = i * s.buffer.duration;
  (l2.startsWith("wt_") ? 1 : t.loop) && (s.loop = true, s.loopStart = d * s.buffer.duration - u, s.loopEnd = r * s.buffer.duration - u);
  const X = s.buffer.duration / s.playbackRate.value, Z2 = (b2 - i) * X;
  return { bufferSource: s, offset: u, bufferDuration: X, sliceDuration: Z2 };
};
var be = (t, e, n, c = 0) => {
  const o = n ? `sound "${n}:${c}"` : "sample";
  if (t = t.replace("#", "%23"), !Lt[t]) {
    F(`[sampler] load ${o}..`, "load-sample", { url: t });
    const a = Date.now();
    Lt[t] = fetch(t).then((s) => s.arrayBuffer()).then(async (s) => {
      const l2 = Date.now() - a, d = $e(s.byteLength);
      F(`[sampler] load ${o}... done! loaded ${d} in ${l2}ms`, "loaded-sample", { url: t });
      const r = await e.decodeAudioData(s);
      return Jt[t] = r, r;
    });
  }
  return Lt[t];
};
function cn(t) {
  const e = G(), n = e.createBuffer(t.numberOfChannels, t.length, e.sampleRate);
  for (let c = 0; c < t.numberOfChannels; c++)
    n.copyToChannel(t.getChannelData(c).slice().reverse(), c, c);
  return n;
}
var Yn = (t) => Jt[t];
function Xe(t) {
  if (t.startsWith("bubo:")) {
    const [e, n] = t.split(":");
    t = `github:Bubobubobubobubo/dough-${n}`;
  }
  return t;
}
function Ze(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, c] = t.split("github:");
  return c = c.endsWith("/") ? c.slice(0, -1) : c, c.split("/").length === 2 && (c += "/main"), `https://raw.githubusercontent.com/${c}/${e}`;
}
var on = (t, e, n = t._base || "") => Object.entries(t).forEach(([c, o]) => {
  if (typeof o == "string" && (o = [o]), typeof o != "object")
    throw new Error("wrong sample map format for " + c);
  n = o._base || n, n = Xe(n), n.startsWith("github:") && (n = Ze(n, ""));
  const a = (s) => n + s;
  Array.isArray(o) ? o = o.map(a) : o = Object.fromEntries(
    Object.entries(o).map(([s, l2]) => [s, (typeof l2 == "string" ? [l2] : l2).map(a)])
  ), e(c, o);
});
var he = {};
function Jn(t, e) {
  he[t] = e;
}
function sn(t) {
  const e = Object.entries(he).find(([n]) => t.startsWith(n));
  if (e)
    return e[1];
}
var an = async (t, e = t._base || "", n = {}) => {
  if (typeof t == "string") {
    const a = sn(t);
    if (a)
      return a(t);
    if (t = Xe(t), t.startsWith("github:") && (t = Ze(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), t.startsWith("shabda:")) {
      let [l2, d] = t.split("shabda:");
      t = `https://shabda.ndre.gr/${d}.json?strudel=1`;
    }
    if (t.startsWith("shabda/speech")) {
      let [l2, d] = t.split("shabda/speech");
      d = d.startsWith("/") ? d.substring(1) : d;
      let [r, i] = d.split(":"), b2 = "f", u = "en-GB";
      r && ([u, b2] = r.split("/")), t = `https://shabda.ndre.gr/speech/${i}.json?gender=${b2}&language=${u}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const s = t.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(t).then((l2) => l2.json()).then((l2) => an(l2, e || l2._base || s, n)).catch((l2) => {
      throw console.error(l2), new Error(`error loading "${t}"`);
    });
  }
  const { prebake: c, tag: o } = n;
  on(
    t,
    (a, s) => E(a, (l2, d, r) => ln(l2, d, r, s), {
      type: "sample",
      samples: s,
      baseUrl: e,
      prebake: c,
      tag: o
    }),
    e
  );
};
var de = [];
async function ln(t, e, n, c, o) {
  let {
    s: a,
    nudge: s = 0,
    // TODO: is this in seconds?
    cut: l2,
    loop: d,
    clip: r = void 0,
    // if set, samples will be cut off when the hap ends
    n: i = 0,
    speed: b2 = 1,
    // sample playback speed
    duration: u
  } = e;
  if (b2 === 0)
    return;
  const m = G();
  let [X, Z2, p, y] = v([e.attack, e.decay, e.sustain, e.release]);
  const { bufferSource: h, sliceDuration: V2, offset: f2 } = await nn(e, c, o);
  if (m.currentTime > t) {
    F(`[sampler] still loading sound "${a}:${i}"`, "highlight");
    return;
  }
  if (!h) {
    F(`[sampler] could not load "${a}:${i}"`, "error");
    return;
  }
  let x = Zt(h.detune, e, t);
  const M = t + s;
  h.start(M, f2);
  const N = m.createGain(), g = h.connect(N);
  r == null && d == null && e.release == null && (u = V2);
  let S2 = t + u;
  B(g.gain, X, Z2, p, y, 0, 1, t, S2, "linear"), Xt(h.detune, e, t, S2);
  const K2 = m.createGain();
  g.connect(K2), h.onended = function() {
    h.disconnect(), x == null ? void 0 : x.stop(), g.disconnect(), K2.disconnect(), n();
  };
  let j3 = S2 + y + 0.01;
  h.stop(j3);
  const H = { node: K2, bufferSource: h, stop: (P2) => {
    h.stop(P2);
  } };
  if (l2 !== void 0) {
    const P2 = de[l2];
    P2 && (P2.node.gain.setValueAtTime(1, M), P2.node.gain.linearRampToValueAtTime(0, M + 0.01)), de[l2] = H;
  }
  return H;
}
var pe = 128;
var Tt = "System Standard";
var ye = pe;
function dn(t) {
  ye = parseInt(t) ?? pe;
}
var Ge = false;
function rn(t) {
  Ge = t == true;
}
var at = map();
function E(t, e, n = {}) {
  t = t.toLowerCase().replace(/\s+/g, "_"), at.setKey(t, { onTrigger: e, data: n });
}
var Ve = (t) => t;
function q2(t) {
  return Ve(t);
}
function Cn(t) {
  Ve = t;
}
function wt(t) {
  for (const n in t)
    t[n.toLowerCase()] = t[n];
  const e = at.get();
  for (const n in e) {
    const [c, o] = n.split("_");
    if (!o) continue;
    const a = t[c];
    if (a) {
      if (typeof a == "string")
        e[`${a}_${o}`.toLowerCase()] = e[n];
      else if (Array.isArray(a))
        for (const s of a)
          e[`${s}_${o}`.toLowerCase()] = e[n];
    }
  }
  at.set({ ...e });
}
async function un(t) {
  const n = await (await fetch(t)).json();
  wt(n);
}
async function In(...t) {
  switch (t.length) {
    case 1:
      return typeof t[0] == "string" ? un(t[0]) : wt(t[0]);
    case 2:
      return wt({ [t[0]]: t[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + t.length);
  }
}
function gt(t) {
  return at.get()[t.toLowerCase()];
}
var mn = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: true });
  let t = await navigator.mediaDevices.enumerateDevices();
  t = t.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const e = /* @__PURE__ */ new Map();
  return e.set(Tt, ""), t.forEach((n) => {
    e.set(n.label, n.deviceId);
  }), e;
};
var We = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  byteBeatExpression: "0",
  delayfeedback: 0.5,
  delaytime: 0.25,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
var Ct = new Map(Object.entries(We));
function fe(t, e) {
  Ct.set(t, e);
}
function L(t) {
  return Ct.get(t);
}
function Pn(t) {
  Object.keys(t).forEach((e) => {
    fe(e, t[e]);
  });
}
function bn() {
  Ct = new Map(Object.entries(We));
}
function kn(t) {
  bn(), t === "1.0" && fe("fanchor", 0.5);
}
var Bn = () => at.set({});
var ht;
var Xn = () => (ht = new AudioContext(), ht);
var G = () => ht || Xn();
function vn() {
  return G().currentTime;
}
var Kt;
function Zn() {
  return Kt || (Kt = G().audioWorklet.addModule(Oe)), Kt;
}
async function hn(t = {}) {
  const {
    disableWorklets: e = false,
    maxPolyphony: n,
    audioDeviceName: c = Tt,
    multiChannelOrbits: o = false
  } = t;
  if (dn(n), rn(o), typeof window > "u")
    return;
  const a = G();
  if (c != null && c != Tt)
    try {
      const l2 = (await mn()).get(c), d = (l2 ?? "").length > 0;
      a.sinkId !== l2 && d && await a.setSinkId(l2), F(
        `[superdough] Audio Device set to ${c}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      F("[superdough] failed to set audio interface", "warning");
    }
  if (await a.resume(), e) {
    F("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await Zn(), F("[superdough] AudioWorklets loaded");
  } catch (s) {
    console.warn("could not load AudioWorklet effects", s);
  }
  F("[superdough] ready");
}
var St;
async function Qn(t) {
  return St || (St = new Promise((e) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await hn(t), e();
    });
  })), St;
}
var O = {};
var pt;
var _;
function pn() {
  const t = G(), e = t.destination.maxChannelCount;
  t.destination.channelCount = e, pt = new ChannelMergerNode(t, { numberOfInputs: t.destination.channelCount }), _ = new GainNode(t), pt.connect(_), _.connect(t.destination);
}
var It = (t, e = [0, 1]) => {
  const n = G();
  pt == null && pn();
  const c = new StereoPannerNode(n);
  t.connect(c);
  const o = new ChannelSplitterNode(n, {
    numberOfOutputs: c.channelCount
  });
  c.connect(o), e.forEach((a, s) => {
    o.connect(pt, s % c.channelCount, a % n.destination.channelCount);
  });
};
var jn = () => {
  _ != null && (_.gain.linearRampToValueAtTime(0, G().currentTime + 0.01), _ = null);
};
function yn(t, e, n, c, o) {
  var _a;
  if (n = st(n, 0, 0.98), !O[t]) {
    const s = G().createFeedbackDelay(1, e, n);
    (_a = s.start) == null ? void 0 : _a.call(s, c), It(s, o), O[t] = s;
  }
  return O[t].delayTime.value !== e && O[t].delayTime.setValueAtTime(e, c), O[t].feedback.value !== n && O[t].feedback.setValueAtTime(n, c), O[t];
}
function xe(t, e, n, c = {}) {
  return I(t, "lfo-processor", {
    frequency: 1,
    depth: 1,
    skew: 0,
    phaseoffset: 0,
    time: e,
    end: n,
    shape: 1,
    dcoffset: -0.5,
    ...c
  });
}
function Gn(t, e, n = 1, c = 0.5, o = 1e3, a = 2e3) {
  const s = G(), l2 = xe(s, t, e, { frequency: n, depth: a * 2 }), d = 2;
  let r = 0;
  const i = [];
  for (let b2 = 0; b2 < d; b2++) {
    const u = s.createBiquadFilter();
    u.type = "notch", u.gain.value = 1, u.frequency.value = o + r, u.Q.value = 2 - Math.min(Math.max(c * 2, 0), 1.9), l2.connect(u.detune), r += 282, b2 > 0 && i[b2 - 1].connect(u), i.push(u);
  }
  return i[i.length - 1];
}
function Vn(t) {
  t = t ?? 0;
  const e = ["12db", "ladder", "24db"];
  return typeof t == "number" ? e[Math.floor(me(t, e.length))] : t;
}
var J = {};
var ut = (t, e) => t !== void 0 && t !== e;
function Wn(t, e, n, c, o, a, s) {
  if (!J[t]) {
    const d = G().createReverb(e, n, c, o, a);
    It(d, s), J[t] = d;
  }
  return (ut(e, J[t].duration) || ut(n, J[t].fade) || ut(c, J[t].lp) || ut(o, J[t].dim) || J[t].ir !== a) && J[t].generate(e, n, c, o, a), J[t];
}
var C = {};
var $ = {};
function fn(t, e = 1024, n = 0.5) {
  if (!C[t]) {
    const c = G().createAnalyser();
    c.fftSize = e, c.smoothingTimeConstant = n, C[t] = c, $[t] = new Float32Array(C[t].frequencyBinCount);
  }
  return C[t].fftSize !== e && (C[t].fftSize = e, $[t] = new Float32Array(C[t].frequencyBinCount)), C[t];
}
function Un(t = "time", e = 1) {
  const n = {
    time: () => {
      var _a;
      return (_a = C[e]) == null ? void 0 : _a.getFloatTimeDomainData($[e]);
    },
    frequency: () => {
      var _a;
      return (_a = C[e]) == null ? void 0 : _a.getFloatFrequencyData($[e]);
    }
  }[t];
  if (!n)
    throw new Error(`getAnalyzerData: ${t} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), $[e];
}
function Ht(t, e, n) {
  const c = k(n);
  return t.connect(c), c.connect(e), c;
}
function On() {
  O = {}, J = {}, C = {}, $ = {};
}
var ot = /* @__PURE__ */ new Map();
function re(t) {
  return (Array.isArray(t) ? t : [t]).map((e) => e - 1);
}
var xn = async (t, e, n, c) => {
  var _a, _b, _c;
  const o = G();
  e = typeof e == "string" && e.startsWith("=") ? Number(e.slice(1)) : o.currentTime + e;
  let { stretch: a } = t;
  if (a != null && (e = e - 0.04), typeof t != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${t}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (t.duration = n, e < o.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${e.toFixed(2)}, now: ${o.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    s = L("s"),
    bank: l2,
    source: d,
    gain: r = L("gain"),
    postgain: i = L("postgain"),
    density: b2 = L("density"),
    // filters
    fanchor: u = L("fanchor"),
    drive: m = 0.69,
    // low pass
    cutoff: X,
    lpenv: Z2,
    lpattack: p,
    lpdecay: y,
    lpsustain: h,
    lprelease: V2,
    resonance: f2 = L("resonance"),
    // high pass
    hpenv: x,
    hcutoff: M,
    hpattack: N,
    hpdecay: g,
    hpsustain: S2,
    hprelease: K2,
    hresonance: j3 = L("hresonance"),
    // band pass
    bpenv: z,
    bandf: H,
    bpattack: P2,
    bpdecay: Gt,
    bpsustain: T,
    bprelease: et2,
    bandq: U = L("bandq"),
    //phaser
    phaserrate: lt2,
    phaserdepth: Pt = L("phaserdepth"),
    phasersweep: Re,
    phasercenter: Le,
    //
    coarse: kt,
    crush: Bt,
    shape: vt,
    shapevol: Vt = L("shapevol"),
    distort: Qt,
    distortvol: Wt = L("distortvol"),
    pan: jt,
    vowel: Ut,
    delay: dt = L("delay"),
    delayfeedback: Ot = L("delayfeedback"),
    delaytime: Dt2 = L("delaytime"),
    orbit: nt2 = L("orbit"),
    room: Et,
    roomfade: ge2,
    roomlp: Ke,
    roomdim: Se,
    roomsize: He,
    ir: ft,
    i: At = L("i"),
    velocity: xt = L("velocity"),
    analyze: qt,
    // analyser wet
    fft: Ne = L("fft"),
    // fftSize 0 - 10
    compressor: _t,
    compressorRatio: Fe,
    compressorKnee: Te,
    compressorAttack: we2,
    compressorRelease: Ye2
  } = t;
  const Mt = re(
    Ge && nt2 > 0 ? [nt2 * 2 - 1, nt2 * 2] : L("channels")
  ), Je = t.channels != null ? re(t.channels) : Mt;
  r = q2(Q(r, 1)), i = q2(i), Vt = q2(Vt), Wt = q2(Wt), dt = q2(dt), xt = q2(xt), r *= xt;
  const $t = Math.round(Math.random() * 1e6);
  for (let W3 = 0; W3 <= ot.size - ye; W3++) {
    const D2 = ot.entries().next(), w = D2.value[1], Y = D2.value[0], ce = e + 0.25;
    (_b = (_a = w == null ? void 0 : w.node) == null ? void 0 : _a.gain) == null ? void 0 : _b.linearRampToValueAtTime(0, ce), (_c = w == null ? void 0 : w.stop) == null ? void 0 : _c.call(w, ce), ot.delete(Y);
  }
  let A = [];
  l2 && s && (s = `${l2}_${s}`, t.s = s);
  let rt2;
  if (d)
    rt2 = d(e, t, n, c);
  else if (gt(s)) {
    const { onTrigger: W3 } = gt(s), w = await W3(e, t, () => {
      A.forEach((Y) => Y == null ? void 0 : Y.disconnect()), ot.delete($t);
    });
    w && (rt2 = w.node, ot.set($t, w));
  } else
    throw new Error(`sound ${s} not found! Is it loaded?`);
  if (!rt2)
    return;
  if (o.currentTime > e) {
    F("[webaudio] skip hap: still loading", o.currentTime - e);
    return;
  }
  const R3 = [];
  R3.push(rt2), a !== void 0 && R3.push(I(o, "phase-vocoder-processor", { pitchFactor: a })), R3.push(k(r));
  const it2 = Vn(t.ftype);
  if (X !== void 0) {
    let W3 = () => zt(
      o,
      "lowpass",
      X,
      f2,
      p,
      y,
      h,
      V2,
      Z2,
      e,
      e + n,
      u,
      it2,
      m
    );
    R3.push(W3()), it2 === "24db" && R3.push(W3());
  }
  if (M !== void 0) {
    let W3 = () => zt(
      o,
      "highpass",
      M,
      j3,
      N,
      g,
      S2,
      K2,
      x,
      e,
      e + n,
      u
    );
    R3.push(W3()), it2 === "24db" && R3.push(W3());
  }
  if (H !== void 0) {
    let W3 = () => zt(
      o,
      "bandpass",
      H,
      U,
      P2,
      Gt,
      T,
      et2,
      z,
      e,
      e + n,
      u
    );
    R3.push(W3()), it2 === "24db" && R3.push(W3());
  }
  if (Ut !== void 0) {
    const W3 = o.createVowelFilter(Ut);
    R3.push(W3);
  }
  if (kt !== void 0 && R3.push(I(o, "coarse-processor", { coarse: kt })), Bt !== void 0 && R3.push(I(o, "crush-processor", { crush: Bt })), vt !== void 0 && R3.push(I(o, "shape-processor", { shape: vt, postgain: Vt })), Qt !== void 0 && R3.push(I(o, "distort-processor", { distort: Qt, postgain: Wt })), _t !== void 0 && R3.push(
    De(o, _t, Fe, Te, we2, Ye2)
  ), jt !== void 0) {
    const W3 = o.createStereoPanner();
    W3.pan.value = 2 * jt - 1, R3.push(W3);
  }
  if (lt2 !== void 0 && Pt > 0) {
    const W3 = Gn(e, e + n, lt2, Pt, Le, Re);
    R3.push(W3);
  }
  const ct2 = new GainNode(o, { gain: i });
  R3.push(ct2), It(ct2, Je);
  let te;
  if (dt > 0 && Dt2 > 0 && Ot > 0) {
    const W3 = yn(nt2, Dt2, Ot, e, Mt);
    te = Ht(ct2, W3, dt), A.push(te);
  }
  let ee2;
  if (Et > 0) {
    let W3;
    if (ft !== void 0) {
      let w, Y = gt(ft);
      Array.isArray(Y) ? w = Y.data.samples[At % Y.data.samples.length] : typeof Y == "object" && (w = Object.values(Y.data.samples).flat()[At % Object.values(Y.data.samples).length]), W3 = await be(w, o, ft, 0);
    }
    const D2 = Wn(nt2, He, ge2, Ke, Se, W3, Mt);
    ee2 = Ht(ct2, D2, Et), A.push(ee2);
  }
  let ne;
  if (qt) {
    const W3 = fn(qt, 2 ** (Ne + 5));
    ne = Ht(ct2, W3, 1), A.push(ne);
  }
  R3.slice(1).reduce((W3, D2) => W3.connect(D2), R3[0]), A = A.concat(R3);
};
var Dn = (t, e, n, c) => {
  xn(e, t - n, e.duration / c, c);
};
var Nt = {};
function Mn(t, e) {
  const n = G();
  if (Nt[t])
    return Nt[t];
  const c = 2 * n.sampleRate, o = n.createBuffer(1, c, n.sampleRate), a = o.getChannelData(0);
  let s = 0, l2, d, r, i, b2, u, m;
  l2 = d = r = i = b2 = u = m = 0;
  for (let X = 0; X < c; X++)
    if (t === "white")
      a[X] = Math.random() * 2 - 1;
    else if (t === "brown") {
      let Z2 = Math.random() * 2 - 1;
      a[X] = (s + 0.02 * Z2) / 1.02, s = a[X];
    } else if (t === "pink") {
      let Z2 = Math.random() * 2 - 1;
      l2 = 0.99886 * l2 + Z2 * 0.0555179, d = 0.99332 * d + Z2 * 0.0750759, r = 0.969 * r + Z2 * 0.153852, i = 0.8665 * i + Z2 * 0.3104856, b2 = 0.55 * b2 + Z2 * 0.5329522, u = -0.7616 * u - Z2 * 0.016898, a[X] = l2 + d + r + i + b2 + u + m + Z2 * 0.5362, a[X] *= 0.11, m = Z2 * 0.115926;
    } else if (t === "crackle") {
      const Z2 = e * 0.01;
      Math.random() < Z2 ? a[X] = Math.random() * 2 - 1 : a[X] = 0;
    }
  return t !== "crackle" && (Nt[t] = o), o;
}
function Me(t = "white", e, n = 0.02) {
  const o = G().createBufferSource();
  return o.buffer = Mn(t, n), o.loop = true, o.start(e), {
    node: o,
    stop: (a) => o.stop(a)
  };
}
function zn(t, e, n) {
  const c = Me("pink", n);
  return {
    node: Ee2(t, c.node, e),
    stop: (a) => c == null ? void 0 : c.stop(a)
  };
}
var bt = (t) => {
  let { note: e, freq: n } = t;
  return e = e || 36, typeof e == "string" && (e = yt(e)), !n && typeof e == "number" && (n = ue(e)), Number(n);
};
function mt(t) {
  var _a;
  t != null && (t.disconnect(), (_a = t.parameters.get("end")) == null ? void 0 : _a.setValueAtTime(0, 0));
}
var Rn = ["triangle", "square", "sawtooth", "sine"];
var Ln = ["pink", "white", "brown", "crackle"];
function En() {
  [...Rn].forEach((t) => {
    E(
      t,
      (e, n, c) => {
        const [o, a, s, l2] = v(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let d = Kn(t, e, n), { node: r, stop: i, triggerRelease: b2 } = d;
        const u = k(0.3), { duration: m } = n;
        r.onended = () => {
          r.disconnect(), u.disconnect(), c();
        };
        const X = k(1);
        let Z2 = r.connect(u).connect(X);
        const p = e + m;
        B(Z2.gain, o, a, s, l2, 0, 1, e, p, "linear");
        const y = p + l2 + 0.01;
        return b2 == null ? void 0 : b2(y), i(y), {
          node: Z2,
          stop: (h) => {
            i(h);
          }
        };
      },
      { type: "synth", prebake: true }
    );
  }), E(
    "supersaw",
    (t, e, n) => {
      const c = G();
      let { duration: o, n: a, unison: s = 5, spread: l2 = 0.6, detune: d } = e;
      d = d ?? a ?? 0.18;
      const r = bt(e), [i, b2, u, m] = v(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), X = t + o, Z2 = X + m + 0.01, p = st(s, 1, 100);
      let y = p > 1 ? st(l2, 0, 1) : 0, h = I(
        c,
        "supersaw-oscillator",
        {
          frequency: r,
          begin: t,
          end: Z2,
          freqspread: d,
          voices: p,
          panspread: y
        },
        {
          outputChannelCount: [2]
        }
      );
      const V2 = 1 / Math.sqrt(p);
      Xt(h.parameters.get("detune"), e, t, X);
      const f2 = Zt(h.parameters.get("detune"), e, t), x = Ft(h.parameters.get("frequency"), e, t);
      let M = k(1);
      M = h.connect(M), B(M.gain, i, b2, u, m, 0, 0.3 * V2, t, X, "linear");
      let N = Rt(
        c,
        () => {
          mt(h), M.disconnect(), n(), x == null ? void 0 : x.stop(), f2 == null ? void 0 : f2.stop();
        },
        t,
        Z2
      );
      return {
        node: M,
        stop: (g) => {
          N.stop(g);
        }
      };
    },
    { prebake: true, type: "synth" }
  ), E(
    "bytebeat",
    (t, e, n) => {
      const c = [
        "(t%255 >= t/255%255)*255",
        "(t*(t*8%60 <= 300)|(-t)*(t*4%512 < 256))+t/400",
        "t",
        "t*(t >> 10^t)",
        "t&128",
        "t&t>>8",
        "((t%255+t%128+t%64+t%32+t%16+t%127.8+t%64.8+t%32.8+t%16.8)/3)",
        "((t%64+t%63.8+t%64.15+t%64.35+t%63.5)/1.25)",
        "(t&(t>>7)-t)",
        "(sin(t*PI/128)*127+127)",
        "((t^t/2+t+64*(sin((t*PI/64)+(t*PI/32768))+64))%128*2)",
        "((t^t/2+t+64*(cos >> 0))%127.85*2)",
        "((t^t/2+t+64)%128*2)",
        "(((t * .25)^(t * .25)/100+(t * .25))%128)*2",
        "((t^t/2+t+64)%7 * 24)"
      ], { n: o = 0 } = e, a = bt(e), { byteBeatExpression: s = c[o % c.length], byteBeatStartTime: l2 } = e, d = G();
      let { duration: r } = e;
      const [i, b2, u, m] = v(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), X = t + r, Z2 = X + m + 0.01;
      let p = I(
        d,
        "byte-beat-processor",
        {
          frequency: a,
          begin: t,
          end: Z2
        },
        {
          outputChannelCount: [2]
        }
      );
      p.port.postMessage({ codeText: s, byteBeatStartTime: l2, frequency: a });
      let y = k(1);
      y = p.connect(y), B(y.gain, i, b2, u, m, 0, 1, t, X, "linear");
      let h = Rt(
        d,
        () => {
          mt(p), y.disconnect(), n();
        },
        t,
        Z2
      );
      return {
        node: y,
        stop: (V2) => {
          h.stop(V2);
        }
      };
    },
    { prebake: true, type: "synth" }
  ), E(
    "pulse",
    (t, e, n) => {
      const c = G();
      let { pwrate: o, pwsweep: a } = e;
      a == null && (o != null ? a = 0.3 : a = 0), o == null && a != null && (o = 1);
      let { duration: s, pw: l2 = 0.5 } = e;
      const d = bt(e), [r, i, b2, u] = v(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), m = t + s, X = m + u + 0.01;
      let Z2 = I(
        c,
        "pulse-oscillator",
        {
          frequency: d,
          begin: t,
          end: X,
          pulsewidth: l2
        },
        {
          outputChannelCount: [2]
        }
      );
      Xt(Z2.parameters.get("detune"), e, t, m);
      const p = Zt(Z2.parameters.get("detune"), e, t), y = Ft(Z2.parameters.get("frequency"), e, t);
      let h = k(1);
      h = Z2.connect(h), B(h.gain, r, i, b2, u, 0, 1, t, m, "linear");
      let V2;
      a != 0 && (V2 = xe(c, t, X, { frequency: o, depth: a }), V2.connect(Z2.parameters.get("pulsewidth")));
      let f2 = Rt(
        c,
        () => {
          mt(Z2), mt(V2), h.disconnect(), n(), y == null ? void 0 : y.stop(), p == null ? void 0 : p.stop();
        },
        t,
        X
      );
      return {
        node: h,
        stop: (x) => {
          f2.stop(x);
        }
      };
    },
    { prebake: true, type: "synth" }
  ), [...Ln].forEach((t) => {
    E(
      t,
      (e, n, c) => {
        const [o, a, s, l2] = v(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let d, { density: r } = n;
        d = Me(t, e, r);
        let { node: i, stop: b2, triggerRelease: u } = d;
        const m = k(0.3), { duration: X } = n;
        i.onended = () => {
          i.disconnect(), m.disconnect(), c();
        };
        const Z2 = k(1);
        let p = i.connect(m).connect(Z2);
        const y = e + X;
        B(p.gain, o, a, s, l2, 0, 1, e, y, "linear");
        const h = y + l2 + 0.01;
        return u == null ? void 0 : u(h), b2(h), {
          node: p,
          stop: (V2) => {
            b2(V2);
          }
        };
      },
      { type: "synth", prebake: true }
    );
  });
}
function gn(t, e) {
  const n = new Float32Array(t + 1), c = new Float32Array(t + 1), o = G(), a = o.createOscillator(), s = {
    sawtooth: (r) => [0, -1 / r],
    square: (r) => [0, r % 2 === 0 ? 0 : 1 / r],
    triangle: (r) => [r % 2 === 0 ? 0 : 1 / (r * r), 0]
  };
  if (!s[e])
    throw new Error(`unknown wave type ${e}`);
  n[0] = 0, c[0] = 0;
  let l2 = 1;
  for (; l2 <= t; ) {
    const [r, i] = s[e](l2);
    n[l2] = r, c[l2] = i, l2++;
  }
  const d = o.createPeriodicWave(n, c);
  return a.setPeriodicWave(d), a;
}
function Kn(t, e, n) {
  let { n: c, duration: o, noise: a = 0 } = n, s;
  !c || t === "sine" ? (s = G().createOscillator(), s.type = t || "triangle") : s = gn(c, t), s.frequency.value = bt(n), s.start(e);
  let l2 = Zt(s.detune, n, e);
  Xt(s.detune, n, e, e + o);
  const d = Ft(s.frequency, n, e);
  let r;
  return a && (r = zn(s, a, e)), {
    node: (r == null ? void 0 : r.node) || s,
    stop: (i) => {
      d.stop(i), l2 == null ? void 0 : l2.stop(i), r == null ? void 0 : r.stop(i), s.stop(i);
    },
    triggerRelease: (i) => {
    }
  };
}
function Sn(t = 1, e = 0.05, n = 220, c = 0, o = 0, a = 0.1, s = 0, l2 = 1, d = 0, r = 0, i = 0, b2 = 0, u = 0, m = 0, X = 0, Z2 = 0, p = 0, y = 1, h = 0, V2 = 0) {
  let f2 = Math.PI * 2, x = G().sampleRate, M = (lt2) => lt2 > 0 ? 1 : -1, N = d *= 500 * f2 / x / x, g = n *= (1 + e * 2 * Math.random() - e) * f2 / x, S2 = [], K2 = 0, j3 = 0, z = 0, H = 1, P2 = 0, Gt = 0, T = 0, et2, U;
  for (c = c * x + 9, h *= x, o *= x, a *= x, p *= x, r *= 500 * f2 / x ** 3, X *= f2 / x, i *= f2 / x, b2 *= x, u = u * x | 0, U = c + h + o + a + p | 0; z < U; S2[z++] = T)
    ++Gt % (Z2 * 100 | 0) || (T = s ? s > 1 ? s > 2 ? s > 3 ? Math.sin((K2 % f2) ** 3) : Math.max(Math.min(Math.tan(K2), 1), -1) : 1 - (2 * K2 / f2 % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(K2 / f2) - K2 / f2) : Math.sin(K2), T = (u ? 1 - V2 + V2 * Math.sin(f2 * z / u) : 1) * M(T) * Math.abs(T) ** l2 * // curve 0=square, 2=pointy
    t * 1 * // envelope
    (z < c ? z / c : z < c + h ? 1 - (z - c) / h * (1 - y) : z < c + h + o ? y : z < U - p ? (U - z - p) / a * // release falloff
    y : 0), T = p ? T / 2 + (p > z ? 0 : (z < U - p ? 1 : (U - z) / p) * // release delay
    S2[z - p | 0] / 2) : T), et2 = (n += d += r) * // frequency
    Math.cos(X * j3++), K2 += et2 - et2 * m * (1 - (Math.sin(z) + 1) * 1e9 % 2), H && ++H > b2 && (n += i, g += i, H = 0), u && !(++P2 % u) && (n = g, d = N, H || (H = 1));
  return S2;
}
var Hn = (t, e) => {
  let {
    s: n,
    note: c = 36,
    freq: o,
    //
    zrand: a = 0,
    attack: s = 0,
    decay: l2 = 0,
    sustain: d = 0.8,
    release: r = 0.1,
    curve: i = 1,
    slide: b2 = 0,
    deltaSlide: u = 0,
    pitchJump: m = 0,
    pitchJumpTime: X = 0,
    lfo: Z2 = 0,
    znoise: p = 0,
    zmod: y = 0,
    zcrush: h = 0,
    zdelay: V2 = 0,
    tremolo: f2 = 0,
    duration: x = 0.2,
    zzfx: M
  } = t;
  const N = Math.max(x - s - l2, 0);
  typeof c == "string" && (c = yt(c)), !o && typeof c == "number" && (o = ue(c)), n = n.replace("z_", "");
  const g = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  i = n === "square" ? 0 : i;
  const K2 = (
    /* ZZFX. */
    Sn(...M || [
      0.25,
      // volume
      a,
      o,
      s,
      N,
      r,
      g,
      i,
      b2,
      u,
      m,
      X,
      Z2,
      p,
      y,
      h,
      V2,
      d,
      // sustain volume!
      l2,
      f2
    ])
  ), j3 = G(), z = j3.createBuffer(1, K2.length, j3.sampleRate);
  z.getChannelData(0).set(K2);
  const H = G().createBufferSource();
  return H.buffer = z, H.start(e), {
    node: H
  };
};
function An() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((t) => {
    E(
      t,
      (e, n, c) => {
        const { node: o } = Hn({ s: t, ...n }, e);
        return o.onended = () => {
          o.disconnect(), c();
        }, {
          node: o,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: true }
    );
  });
}
var tt2;
async function Nn(t, e) {
  const n = `dsp-worklet-${Date.now()}`, c = `${e}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, a = `data:text/javascript;base64,${btoa(c)}`;
  await t.audioWorklet.addModule(a);
  const s = new AudioWorkletNode(t, n);
  return { node: s, stop: () => s.port.postMessage("stop") };
}
var ze = () => {
  var _a;
  tt2 && (tt2 == null ? void 0 : tt2.stop(), (_a = tt2 == null ? void 0 : tt2.node) == null ? void 0 : _a.disconnect());
};
typeof window < "u" && window.addEventListener("message", (t) => {
  var _a;
  t.data === "strudel-stop" ? ze() : ((_a = t.data) == null ? void 0 : _a.dough) && (tt2 == null ? void 0 : tt2.node.port.postMessage(t.data));
});
var qn = async (t) => {
  const e = G();
  ze(), tt2 = await Nn(e, t), tt2.node.connect(e.destination);
};
function _n(t, e, n, c, o) {
  window.postMessage({ time: o, dough: e.value, currentTime: n, duration: e.duration, cps: c });
}

// node_modules/@strudel/draw/dist/index.mjs
var Z = (t = "test-canvas", e) => {
  let { contextType: n = "2d", pixelated: o = false, pixelRatio: a = window.devicePixelRatio } = e || {}, r = document.querySelector("#" + t);
  if (!r) {
    r = document.createElement("canvas"), r.id = t, r.width = window.innerWidth * a, r.height = window.innerHeight * a, r.style = "pointer-events:none;width:100%;height:100%;position:fixed;top:0;left:0", o && (r.style.imageRendering = "pixelated"), document.body.prepend(r);
    let i;
    window.addEventListener("resize", () => {
      i && clearTimeout(i), i = setTimeout(() => {
        r.width = window.innerWidth * a, r.height = window.innerHeight * a;
      }, 200);
    });
  }
  return r.getContext(n, { willReadFrequently: true });
};
var $2 = {};
function pe2(t) {
  $2[t] !== void 0 && (cancelAnimationFrame($2[t]), delete $2[t]);
}
var R = {};
f.prototype.draw = function(t, e) {
  if (typeof window > "u")
    return this;
  let { id: n = 1, lookbehind: o = 0, lookahead: a = 0 } = e, r = Math.max(Of(), 0);
  pe2(n), o = Math.abs(o), R[n] = (R[n] || []).filter((g) => !g.isInFuture(r));
  let i = this.queryArc(r, r + a).filter((g) => g.hasOnset());
  R[n] = R[n].concat(i);
  let f2;
  const l2 = () => {
    const g = Of(), u = g + a;
    R[n] = R[n].filter((d) => d.isInNearPast(o, g));
    let c = Math.max(f2 || u, u - 1 / 10);
    const b2 = this.queryArc(c, u).filter((d) => d.hasOnset());
    R[n] = R[n].concat(b2), f2 = u, t(R[n], g, u, this), $2[n] = requestAnimationFrame(l2);
  };
  return $2[n] = requestAnimationFrame(l2), this;
};
f.prototype.onPaint = function(t) {
  return this.withState((e) => {
    e.controls.painters || (e.controls.painters = []), e.controls.painters.push(t);
  });
};
f.prototype.getPainters = function() {
  let t = [];
  return this.queryArc(0, 0, { painters: t }), t;
};
var ye2 = {
  background: "#222",
  foreground: "#75baff",
  caret: "#ffcc00",
  selection: "rgba(128, 203, 196, 0.5)",
  selectionMatch: "#036dd626",
  lineHighlight: "#00000050",
  gutterBackground: "transparent",
  gutterForeground: "#8a919966"
};
function W() {
  return ye2;
}
var fe2 = "#22222210";
f.prototype.animate = function({ callback: t, sync: e = false, smear: n = 0.5 } = {}) {
  window.frame && cancelAnimationFrame(window.frame);
  const o = Z();
  let { clientWidth: a, clientHeight: r } = o.canvas;
  a *= window.devicePixelRatio, r *= window.devicePixelRatio;
  let i = n === 0 ? "99" : Number((1 - n) * 100).toFixed(0);
  i = i.length === 1 ? `0${i}` : i, fe2 = `#200010${i}`;
  const f2 = (l2) => {
    let g;
    l2 = Math.round(l2), g = this.slow(1e3).queryArc(l2, l2), o.fillStyle = fe2, o.fillRect(0, 0, a, r), g.forEach((u) => {
      let { x: c, y: b2, w: d, h: w, s: p, r: k2, angle: h = 0, fill: S2 = "darkseagreen" } = u.value;
      if (d *= a, w *= r, k2 !== void 0 && h !== void 0) {
        const v2 = h * 2 * Math.PI, [y, P2] = [(a - d) / 2, (r - w) / 2];
        c = y + Math.cos(v2) * k2 * y, b2 = P2 + Math.sin(v2) * k2 * P2;
      } else
        c *= a - d, b2 *= r - w;
      const A = { ...u.value, x: c, y: b2, w: d, h: w };
      o.fillStyle = S2, p === "rect" ? o.fillRect(c, b2, d, w) : p === "ellipse" && (o.beginPath(), o.ellipse(c + d / 2, b2 + w / 2, d / 2, w / 2, 0, 0, 2 * Math.PI), o.fill()), t && t(o, A, u);
    }), window.frame = requestAnimationFrame(f2);
  };
  return window.frame = requestAnimationFrame(f2), q;
};
var { x: we, y: xe2, w: et, h: tt3, angle: nt, r: rt, fill: at2, smear: ot2 } = qc("x", "y", "w", "h", "angle", "r", "fill", "smear");
var it = l("rescale", function(t, e) {
  return e.mul(we(t).w(t).y(t).h(t));
});
var lt = l("moveXY", function(t, e, n) {
  return n.add(we(t).y(e));
});
var st2 = l("zoomIn", function(t, e) {
  const n = j(1).sub(t).div(2);
  return e.rescale(t).move(n, n);
});
var G2 = (t, e, n) => t * (n - e) + e;
var he2 = (t) => {
  let { value: e } = t;
  typeof t.value != "object" && (e = { value: e });
  let { note: n, n: o, freq: a, s: r } = e;
  if (a)
    return qe(a);
  if (n = n ?? o, typeof n == "string")
    try {
      return ct(n);
    } catch {
      return 0;
    }
  return typeof n == "number" ? n : r ? "_" + r : e;
};
f.prototype.pianoroll = function(t = {}) {
  let { cycles: e = 4, playhead: n = 0.5, overscan: o = 0, hideNegative: a = false, ctx: r = Z(), id: i = 1 } = t, f2 = -e * n, l2 = e * (1 - n);
  const g = (u, c) => (!a || u.whole.begin >= 0) && u.isWithinTime(c + f2, c + l2);
  return this.draw(
    (u, c) => {
      ee({
        ...t,
        time: c,
        ctx: r,
        haps: u.filter((b2) => g(b2, c))
      });
    },
    {
      lookbehind: f2 - o,
      lookahead: l2 + o,
      id: i
    }
  ), this;
};
function ee({
  time: t,
  haps: e,
  cycles: n = 4,
  playhead: o = 0.5,
  flipTime: a = 0,
  flipValues: r = 0,
  hideNegative: i = false,
  inactive: f2 = W().foreground,
  active: l2 = W().foreground,
  background: g = "transparent",
  smear: u = 0,
  playheadColor: c = W().foreground,
  minMidi: b2 = 10,
  maxMidi: d = 90,
  autorange: w = 0,
  timeframe: p,
  fold: k2 = 1,
  vertical: h = 0,
  labels: S2 = false,
  fill: A = 1,
  fillActive: v2 = false,
  strokeActive: y = true,
  stroke: P2,
  hideInactive: H = 0,
  colorizeInactive: q3 = 1,
  fontFamily: C2,
  ctx: s,
  id: _2
} = {}) {
  const T = s.canvas.width, I2 = s.canvas.height;
  let z = -n * o, j3 = n * (1 - o);
  _2 && (e = e.filter((m) => m.hasTag(_2))), p && (console.warn("timeframe is deprecated! use from/to instead"), z = 0, j3 = p);
  const N = h ? I2 : T, E3 = h ? T : I2;
  let L3 = h ? [N, 0] : [0, N];
  const J2 = j3 - z, te = h ? [0, E3] : [E3, 0];
  let K2 = d - b2 + 1, D2 = E3 / K2, Q2 = [];
  a && L3.reverse(), r && te.reverse();
  const { min: ke2, max: Pe2, values: Te } = e.reduce(
    ({ min: m, max: F3, values: X }, Y) => {
      const M = he2(Y);
      return {
        min: M < m ? M : m,
        max: M > F3 ? M : F3,
        values: X.includes(M) ? X : [...X, M]
      };
    },
    { min: 1 / 0, max: -1 / 0, values: [] }
  );
  w && (b2 = ke2, d = Pe2, K2 = d - b2 + 1), Q2 = Te.sort(
    (m, F3) => typeof m == "number" && typeof F3 == "number" ? m - F3 : typeof m == "number" ? 1 : String(m).localeCompare(String(F3))
  ), D2 = k2 ? E3 / Q2.length : E3 / K2, s.fillStyle = g, s.globalAlpha = 1, u || (s.clearRect(0, 0, T, I2), s.fillRect(0, 0, T, I2)), e.forEach((m) => {
    var _a;
    const F3 = m.whole.begin <= t && m.endClipped > t;
    let X = P2 ?? (y && F3), Y = !F3 && A || F3 && v2;
    if (H && !F3)
      return;
    let M = (_a = m.value) == null ? void 0 : _a.color;
    l2 = M || l2, f2 = q3 && M || f2, M = F3 ? l2 : f2, s.fillStyle = Y ? M : "transparent", s.strokeStyle = M;
    const { velocity: Ae2 = 1, gain: qe3 = 1 } = m.value || {};
    s.globalAlpha = Ae2 * qe3;
    const Fe = (m.whole.begin - (a ? j3 : z)) / J2, ne = G2(Fe, ...L3);
    let B3 = G2(m.duration / J2, 0, N);
    const re2 = he2(m), Me2 = k2 ? Q2.indexOf(re2) / Q2.length : (Number(re2) - b2) / K2, ae2 = G2(Me2, ...te);
    let oe2 = 0;
    const ie2 = G2(t / J2, ...L3);
    let V2;
    if (h ? V2 = [
      ae2 + 1 - (r ? D2 : 0),
      // x
      N - ie2 + ne + oe2 + 1 - (a ? 0 : B3),
      // y
      D2 - 2,
      // width
      B3 - 2
      // height
    ] : V2 = [
      ne - ie2 + oe2 + 1 - (a ? B3 : 0),
      // x
      ae2 + 1 - (r ? 0 : D2),
      // y
      B3 - 2,
      // widith
      D2 - 2
      // height
    ], X && s.strokeRect(...V2), Y && s.fillRect(...V2), S2) {
      const Se = m.value.note ?? m.value.s + (m.value.n ? `:${m.value.n}` : ""), { label: le2, activeLabel: Ce } = m.value, He = (F3 && Ce || le2) ?? Se;
      let Ie2 = h ? B3 : D2 * 0.75;
      s.font = `${Ie2}px ${C2 || "monospace"}`, s.fillStyle = /* isActive &&  */
      Y ? "black" : M, s.textBaseline = "top", s.fillText(He, ...V2);
    }
  }), s.globalAlpha = 1;
  const U = G2(-z / J2, ...L3);
  return s.strokeStyle = c, s.beginPath(), h ? (s.moveTo(0, U), s.lineTo(E3, U)) : (s.moveTo(U, 0), s.lineTo(U, E3)), s.stroke(), this;
}
function ve2(t, e = {}) {
  let [n, o] = t;
  n = Math.abs(n);
  const a = o + n, r = a !== 0 ? n / a : 0;
  return { fold: 1, ...e, cycles: a, playhead: r };
}
var je2 = (t = {}) => (e, n, o, a) => ee({ ctx: e, time: n, haps: o, ...ve2(a, t) });
f.prototype.punchcard = function(t) {
  return this.onPaint(je2(t));
};
f.prototype.wordfall = function(t) {
  return this.punchcard({ vertical: 1, labels: 1, stroke: 0, fillActive: 1, active: "white", ...t });
};
function Xe2(t, e, n, o) {
  const a = (t - 90) * Math.PI / 180;
  return [n + Math.cos(a) * e, o + Math.sin(a) * e];
}
var ue2 = (t, e, n, o, a = 0) => Xe2((t + a) * 360, e * t, n, o);
function me2(t) {
  let {
    ctx: e,
    from: n = 0,
    to: o = 3,
    margin: a = 50,
    cx: r = 100,
    cy: i = 100,
    rotate: f2 = 0,
    thickness: l2 = a / 2,
    color: g = W().foreground,
    cap: u = "round",
    stretch: c = 1,
    fromOpacity: b2 = 1,
    toOpacity: d = 1
  } = t;
  n *= c, o *= c, f2 *= c, e.lineWidth = l2, e.lineCap = u, e.strokeStyle = g, e.globalAlpha = b2, e.beginPath();
  let [w, p] = ue2(n, a, r, i, f2);
  e.moveTo(w, p);
  const k2 = 1 / 60;
  let h = n;
  for (; h <= o; ) {
    const [S2, A] = ue2(h, a, r, i, f2);
    e.globalAlpha = (h - n) / (o - n) * d, e.lineTo(S2, A), h += k2;
  }
  e.stroke();
}
function Ye(t) {
  let {
    stretch: e = 1,
    size: n = 80,
    thickness: o = n / 2,
    cap: a = "butt",
    // round butt squar,
    inset: r = 3,
    // start angl,
    playheadColor: i = "#ffffff",
    playheadLength: f2 = 0.02,
    playheadThickness: l2 = o,
    padding: g = 0,
    steady: u = 1,
    activeColor: c = W().foreground,
    inactiveColor: b2 = W().gutterForeground,
    colorizeInactive: d = 0,
    fade: w = true,
    // logSpiral = true,
    ctx: p,
    time: k2,
    haps: h,
    drawTime: S2,
    id: A
  } = t;
  A && (h = h.filter((T) => T.hasTag(A)));
  const [v2, y] = [p.canvas.width, p.canvas.height];
  p.clearRect(0, 0, v2 * 2, y * 2);
  const [P2, H] = [v2 / 2, y / 2], q3 = {
    margin: n / e,
    cx: P2,
    cy: H,
    stretch: e,
    cap: a,
    thickness: o
  }, C2 = {
    ...q3,
    thickness: l2,
    from: r - f2,
    to: r,
    color: i
  }, [s] = S2, _2 = u * k2;
  h.forEach((T) => {
    var _a;
    const I2 = T.whole.begin <= k2 && T.endClipped > k2, z = T.whole.begin - k2 + r, j3 = T.endClipped - k2 + r - g, N = ((_a = T.value) == null ? void 0 : _a.color) || c, E3 = d || I2 ? N : b2, L3 = w ? 1 - Math.abs((T.whole.begin - k2) / s) : 1;
    me2({
      ctx: p,
      ...q3,
      from: z,
      to: j3,
      rotate: _2,
      color: E3,
      fromOpacity: L3,
      toOpacity: L3
    });
  }), me2({
    ctx: p,
    ...C2,
    rotate: _2
  });
}
f.prototype.spiral = function(t = {}) {
  return this.onPaint((e, n, o, a) => Ye({ ctx: e, time: n, haps: o, drawTime: a, ...t }));
};
var Be2 = tt(36);
var ge = (t, e, n, o) => {
  o = o * Math.PI * 2;
  const a = Math.sin(o) * n + t, r = Math.cos(o) * n + e;
  return [a, r];
};
var be2 = (t, e) => 0.5 - Math.log2(t / e) % 1;
function Ve2({
  haps: t,
  ctx: e,
  id: n,
  hapcircles: o = 1,
  circle: a = 0,
  edo: r = 12,
  root: i = Be2,
  thickness: f2 = 3,
  hapRadius: l2 = 6,
  mode: g = "flake",
  margin: u = 10
} = {}) {
  const c = g === "polygon", b2 = g === "flake", d = e.canvas.width, w = e.canvas.height;
  e.clearRect(0, 0, d, w);
  const p = W().foreground, h = Math.min(d, w) / 2 - f2 / 2 - l2 - u, S2 = d / 2, A = w / 2;
  n && (t = t.filter((y) => y.hasTag(n))), e.strokeStyle = p, e.fillStyle = p, e.globalAlpha = 1, e.lineWidth = f2, a && (e.beginPath(), e.arc(S2, A, h, 0, 2 * Math.PI), e.stroke()), r && (Array.from({ length: r }, (y, P2) => {
    const H = be2(i * Math.pow(2, P2 / r), i), [q3, C2] = ge(S2, A, h, H);
    e.beginPath(), e.arc(q3, C2, l2, 0, 2 * Math.PI), e.fill();
  }), e.stroke());
  let v2 = [];
  e.lineWidth = l2, t.forEach((y) => {
    let P2;
    try {
      P2 = Ou(y);
    } catch {
      return;
    }
    const H = be2(P2, i), [q3, C2] = ge(S2, A, h, H), s = y.value.color || p;
    e.strokeStyle = s, e.fillStyle = s;
    const { velocity: _2 = 1, gain: T = 1 } = y.value || {}, I2 = _2 * T;
    e.globalAlpha = I2, v2.push([q3, C2, H, s, I2]), e.beginPath(), o && (e.moveTo(q3 + l2, C2), e.arc(q3, C2, l2, 0, 2 * Math.PI), e.fill()), b2 && (e.moveTo(S2, A), e.lineTo(q3, C2)), e.stroke();
  }), e.strokeStyle = p, e.globalAlpha = 1, c && v2.length && (v2 = v2.sort((y, P2) => y[2] - P2[2]), e.beginPath(), e.moveTo(v2[0][0], v2[0][1]), v2.forEach(([y, P2, H, q3, C2]) => {
    e.strokeStyle = q3, e.globalAlpha = C2, e.lineTo(y, P2);
  }), e.lineTo(v2[0][0], v2[0][1]), e.stroke());
}
f.prototype.pitchwheel = function(t = {}) {
  let { ctx: e = Z(), id: n = 1 } = t;
  return this.tag(n).onPaint(
    (o, a, r) => Ve2({
      ...t,
      time: a,
      ctx: e,
      haps: r.filter((i) => i.isActive(a)),
      id: n
    })
  );
};

// node_modules/@strudel/webaudio/dist/index.mjs
var { Pattern: D, logger: W2, repl: B2 } = dist_exports;
Tn(W2);
var P = (e) => (e.ensureObjectValue(), e.value);
var F2 = (e, t, r, s) => xn(P(t), e - r, t.duration / s, s);
var j2 = (e, t, r, s, c) => xn(P(e), c ? `=${c}` : t, r);
D.prototype.webaudio = function() {
  return this.onTrigger(F2);
};
function K(e = {}) {
  return e = {
    getTime: () => G().currentTime,
    defaultOutput: j2,
    ...e
  }, B2(e);
}
D.prototype.dough = function() {
  return this.onTrigger(_n, 1);
};
function L2(e, {
  align: t = true,
  color: r = "white",
  thickness: s = 3,
  scale: c = 0.25,
  pos: a = 0.75,
  trigger: u = 0,
  ctx: o = Z(),
  id: y = 1
} = {}) {
  o.lineWidth = s, o.strokeStyle = r;
  let p = o.canvas;
  if (!e) {
    o.beginPath();
    let l2 = a * p.height;
    o.moveTo(0, l2), o.lineTo(p.width, l2), o.stroke();
    return;
  }
  const n = Un("time", y);
  o.beginPath();
  const g = e.frequencyBinCount;
  let h = t ? Array.from(n).findIndex((l2, d, f2) => d && f2[d - 1] > -u && l2 <= -u) : 0;
  h = Math.max(h, 0);
  const w = p.width * 1 / g;
  let i = 0;
  for (let l2 = h; l2 < g; l2++) {
    const d = n[l2] + 1, f2 = (a - c * (d - 1)) * p.height;
    l2 === 0 ? o.moveTo(i, f2) : o.lineTo(i, f2), i += w;
  }
  o.stroke();
}
function V(e, { color: t = "white", scale: r = 0.25, pos: s = 0.75, lean: c = 0.5, min: a = -150, max: u = 0, ctx: o = Z(), id: y = 1 } = {}) {
  if (!e) {
    o.beginPath();
    let i = s * n.height;
    o.moveTo(0, i), o.lineTo(n.width, i), o.stroke();
    return;
  }
  const p = Un("frequency", y), n = o.canvas;
  o.fillStyle = t;
  const g = e.frequencyBinCount, h = n.width * 1 / g;
  let w = 0;
  for (let i = 0; i < g; i++) {
    const d = Ee((p[i] - a) / (u - a), 0, 1) * r, f2 = d * n.height, k2 = (s - d * c) * n.height;
    o.fillRect(w, k2, Math.max(h, 1), f2), w += h;
  }
}
function R2(e = 0, t = "0,0,0", r = Z()) {
  e ? (r.fillStyle = `rgba(${t},${1 - e})`, r.fillRect(0, 0, r.canvas.width, r.canvas.height)) : r.clearRect(0, 0, r.canvas.width, r.canvas.height);
}
f.prototype.fscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    () => {
      R2(e.smear, "0,0,0", e.ctx), C[t] && V(C[t], e);
    },
    { id: t }
  );
};
f.prototype.tscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (r) => {
      var _a, _b;
      e.color = ((_b = (_a = r[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.color) || W().foreground, e.color, R2(e.smear, "0,0,0", e.ctx), L2(C[t], e);
    },
    { id: t }
  );
};
f.prototype.scope = f.prototype.tscope;
var S = {};
f.prototype.spectrum = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (r) => {
      var _a, _b;
      e.color = ((_b = (_a = r[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.color) || S[t] || W().foreground, S[t] = e.color, E2(C[t], e);
    },
    { id: t }
  );
};
f.prototype.scope = f.prototype.tscope;
var b = /* @__PURE__ */ new Map();
function E2(e, { thickness: t = 3, speed: r = 1, min: s = -80, max: c = 0, ctx: a = Z(), id: u = 1, color: o } = {}) {
  if (a.lineWidth = t, a.strokeStyle = o, !e)
    return;
  const y = r, p = Un("frequency", u), n = a.canvas;
  a.fillStyle = o;
  const g = e.frequencyBinCount;
  let h = b.get(u) || a.getImageData(0, 0, n.width, n.height);
  b.set(u, h), a.clearRect(0, 0, a.canvas.width, a.canvas.height), a.putImageData(h, -y, 0);
  let w = n.width - r;
  for (let i = 0; i < g; i++) {
    const l2 = Ee((p[i] - s) / (c - s), 0, 1);
    a.globalAlpha = l2;
    const d = Math.log(i + 1) / Math.log(g) * n.height;
    a.fillRect(w, n.height - d, y, 2);
  }
  b.set(u, a.getImageData(0, 0, n.width, n.height));
}
export {
  pe as DEFAULT_MAX_POLYPHONY,
  In as aliasBank,
  C as analysers,
  $ as analysersData,
  Ft as applyFM,
  q2 as applyGainCurve,
  It as connectToDestination,
  zt as createFilter,
  qn as dough,
  _n as doughTrigger,
  V as drawFrequencyScope,
  L2 as drawTimeScope,
  Ee2 as drywet,
  Nn as dspWorklet,
  k as gainNode,
  v as getADSRValues,
  fn as getAnalyserById,
  Un as getAnalyzerData,
  G as getAudioContext,
  vn as getAudioContextCurrentTime,
  mn as getAudioDevices,
  wn as getCachedBuffer,
  De as getCompressor,
  L as getDefaultValue,
  xe as getLfo,
  Yn as getLoadedBuffer,
  Kn as getOscillator,
  B as getParamADSR,
  Xt as getPitchEnvelope,
  en as getSampleBuffer,
  nn as getSampleBufferSource,
  tn as getSampleInfo,
  gt as getSound,
  Zt as getVibratoOscillator,
  I as getWorklet,
  Hn as getZZFX,
  hn as initAudio,
  Qn as initAudioOnFirstClick,
  pn as initializeAudioOutput,
  be as loadBuffer,
  F as logger,
  ln as onTriggerSample,
  jn as panic,
  on as processSampleMap,
  Jn as registerSamplesPrefix,
  E as registerSound,
  En as registerSynthSounds,
  An as registerZZFXSounds,
  bn as resetDefaultValues,
  On as resetGlobalEffects,
  Bn as resetLoadedSounds,
  cn as reverseBuffer,
  an as samples,
  Xn as setDefaultAudioContext,
  fe as setDefaultValue,
  Pn as setDefaultValues,
  Cn as setGainCurve,
  Tn as setLogger,
  dn as setMaxPolyphony,
  rn as setMultiChannelOrbits,
  kn as setVersionDefaults,
  at as soundMap,
  xn as superdough,
  Dn as superdoughTrigger,
  gn as waveformN,
  Rt as webAudioTimeout,
  j2 as webaudioOutput,
  F2 as webaudioOutputTrigger,
  K as webaudioRepl
};
//# sourceMappingURL=@strudel_webaudio.js.map
